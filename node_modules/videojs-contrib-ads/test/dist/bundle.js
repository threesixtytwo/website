(function (videojs$1) {
'use strict';

videojs$1 = videojs$1 && videojs$1.hasOwnProperty('default') ? videojs$1['default'] : videojs$1;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};









var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

QUnit.module('Contrib Ads', window.sharedModuleHooks());

QUnit.test('begins in BeforePreroll', function (assert) {
  assert.equal(this.player.ads._state.constructor.name, 'BeforePreroll');
});

QUnit.test('adstart is fired before a preroll', function (assert) {
  var spy = sinon.spy();

  assert.expect(1);

  this.player.on('adstart', spy);
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(spy.callCount, 1, 'a preroll triggers adstart');
});

QUnit.test('player has the .vjs-has-started class once a preroll begins', function (assert) {
  assert.expect(1);
  this.player.trigger('adsready');

  // This is a bit of a hack in order to not need the test to be async.
  this.player.tech_.trigger('play');
  this.player.ads.startLinearAdMode();
  assert.ok(this.player.hasClass('vjs-has-started'), 'player has .vjs-has-started class');
});

QUnit.test('calls start immediately on play when ads are ready', function (assert) {
  var readyForPrerollSpy = sinon.spy();

  assert.expect(1);

  this.player.on('readyforpreroll', readyForPrerollSpy);
  this.player.trigger('adsready');
  this.player.trigger('loadstart');
  this.player.trigger('play');
  assert.strictEqual(readyForPrerollSpy.callCount, 1, 'readyforpreroll was fired');
});

QUnit.test('adds the ad-mode class when a preroll plays', function (assert) {
  var el;

  assert.expect(1);

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  el = this.player.el();
  assert.ok(this.player.hasClass('vjs-ad-playing'), 'the ad class should be in "' + el.className + '"');
});

QUnit.test('removes the ad-mode class when a preroll finishes', function (assert) {
  var el;

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  el = this.player.el();
  assert.notOk(this.player.hasClass('vjs-ad-playing'), 'the ad class should not be in "' + el.className + '"');

  this.player.trigger('playing');
});

QUnit.test('adds a class while waiting for an ad plugin to load', function (assert) {
  var el;

  assert.expect(1);

  this.player.trigger('play');
  el = this.player.el();
  assert.ok(this.player.hasClass('vjs-ad-loading'), 'the ad loading class should be in "' + el.className + '"');
});

QUnit.test('adds a class while waiting for a preroll', function (assert) {
  var el;

  assert.expect(1);

  this.player.trigger('adsready');
  this.player.trigger('play');
  el = this.player.el();
  assert.ok(this.player.hasClass('vjs-ad-loading'), 'the ad loading class should be in "' + el.className + '"');
});

QUnit.test('removes the loading class when the preroll begins', function (assert) {
  var el;

  assert.expect(1);

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  this.player.trigger('ads-ad-started');
  el = this.player.el();
  assert.notOk(this.player.hasClass('vjs-ad-loading'), 'there should be no ad loading class present in "' + el.className + '"');
});

QUnit.test('removes the loading class when the preroll times out', function (assert) {
  var el;

  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('playing');
  el = this.player.el();
  assert.notOk(this.player.hasClass('vjs-ad-loading'), 'there should be no ad loading class present in "' + el.className + '"');
});

QUnit.test('begins resuming to content if there is no preroll', function (assert) {
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.clock.tick(1);
  this.player.trigger('adtimeout');

  assert.strictEqual(this.player.ads.inAdBreak(), false, 'should not be in an ad break');
  assert.strictEqual(this.player.ads.isContentResuming(), true, 'should be resuming content');
  assert.strictEqual(this.player.ads.isInAdMode(), true, 'should be in ad mode');
});

QUnit.test('removes the poster attribute so it does not flash between videos', function (assert) {
  this.video.poster = 'http://www.videojs.com/img/poster.jpg';
  assert.ok(this.video.poster, 'the poster is present initially');

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.video.poster, '', 'poster is removed');
});

QUnit.test('changing the src triggers "contentupdate"', function (assert) {
  var spy = sinon.spy();

  assert.expect(1);

  this.player.on('contentupdate', spy);

  // set src and trigger synthetic 'loadstart'
  this.player.currentSrc = function () {
    return 'AH HA!!! I AM NOT A REAL SOURCE';
  };
  this.player.trigger('loadstart');
  assert.strictEqual(spy.callCount, 1, 'one contentupdate event fired');
});

QUnit.test('"contentupdate" should fire when src is changed after postroll', function (assert) {
  var contentupdateSpy = sinon.spy();

  this.player.on('contentupdate', contentupdateSpy);

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('ended');
  this.player.trigger('adtimeout');

  // set src and trigger synthetic 'loadstart'
  this.player.src({
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');
  assert.strictEqual(contentupdateSpy.callCount, 1, 'one contentupdate event fired');
});

QUnit.test('"contentupdate" should fire when src is changed after postroll', function (assert) {
  var contentupdateSpy = sinon.spy();

  this.player.on('contentupdate', contentupdateSpy);
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('ended');
  this.player.trigger('adtimeout');
  this.player.trigger('ended');

  // set src and trigger synthetic 'loadstart'
  this.player.src({
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');
  assert.strictEqual(contentupdateSpy.callCount, 1, 'one contentupdate event fired');
});

QUnit.test('changing src does not trigger "contentupdate" during ad playback', function (assert) {
  var spy = sinon.spy();

  this.player.on('contentupdate', spy);

  // enter ad playback mode
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();

  // set src and trigger synthetic 'loadstart'
  this.player.src({
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');

  // finish playing ad
  this.player.ads.endLinearAdMode();
  assert.strictEqual(spy.callCount, 0, 'no contentupdate events fired');
});

QUnit.test('the `_playRequested` flag is set on the first play request', function (assert) {
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads._playRequested, false, 'initially set to false');
  assert.strictEqual(this.player.ads.isInAdMode(), false, 'starts in a content state');

  this.player.trigger('play');
  assert.strictEqual(this.player.ads._playRequested, true, '_playRequested is now true');
  assert.strictEqual(this.player.ads.isInAdMode(), true, 'now in ad state');
});

QUnit.test('ended event happens after postroll errors out', function (assert) {
  var endedSpy = sinon.spy();

  this.player.on('ended', endedSpy);

  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('playing'); // Entered content
  this.player.trigger('ended');
  this.player.trigger('adserror');

  this.clock.tick(1);
  assert.strictEqual(endedSpy.callCount, 1, 'ended event happened');
});

QUnit.test('ended event happens after postroll timed out', function (assert) {
  var endedSpy = sinon.spy();

  this.player.on('ended', endedSpy);

  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('playing'); // Entered content
  this.player.trigger('ended');
  this.player.trigger('adtimeout');

  this.clock.tick(1);
  assert.strictEqual(endedSpy.callCount, 1, 'ended event happened');
});

QUnit.test('ended event happens after postroll skipped', function (assert) {
  var endedSpy = sinon.spy();

  this.player.on('ended', endedSpy);

  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout'); // preroll times out
  this.player.trigger('playing'); // Entered content
  this.player.trigger('ended'); // content ends
  this.player.ads.skipLinearAdMode();

  this.clock.tick(1);
  assert.strictEqual(endedSpy.callCount, 1, 'ended event happened');
});

QUnit.test('an "ended" event is fired after postroll if not fired naturally', function (assert) {
  var endedSpy = sinon.spy();

  this.player.on('ended', endedSpy);

  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout'); // skip preroll
  this.player.trigger('playing'); // return to content
  this.player.trigger('ended'); // handled by redispatch

  assert.strictEqual(endedSpy.callCount, 0, 'no ended event before postroll');

  this.player.ads.startLinearAdMode(); // start postroll
  this.player.ads.endLinearAdMode();
  this.player.trigger('resumeended');
  assert.strictEqual(endedSpy.callCount, 1, 'ended event happened');
});

QUnit.test('ended events when content ends first and second time', function (assert) {
  var endedSpy = sinon.spy();
  this.player.on('ended', endedSpy);

  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout'); // Preroll times out
  this.player.trigger('playing'); // Entered content
  this.player.trigger('ended'); // Triggers readyforpostroll

  this.player.ads.startLinearAdMode(); // Postroll starts
  this.player.ads.endLinearAdMode();
  this.player.trigger('resumeended');

  assert.strictEqual(endedSpy.callCount, 1, 'ended event after postroll');

  this.player.trigger('ended');
  assert.strictEqual(endedSpy.callCount, 2, 'ended event after ads done');
});

QUnit.test('endLinearAdMode during ad break triggers adend', function (assert) {
  var adendSpy = sinon.spy();

  this.player.on('adend', adendSpy);

  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();

  assert.strictEqual(adendSpy.callCount, 0, 'no adend yet');

  this.player.ads.endLinearAdMode();

  assert.strictEqual(adendSpy.callCount, 1, 'adend happened');
});

QUnit.test('calling startLinearAdMode() when already in ad-playback does not trigger adstart', function (assert) {
  var spy = sinon.spy();

  this.player.on('adstart', spy);
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(spy.callCount, 1, 'adstart should have fired');

  // add an extraneous start call
  this.player.ads.startLinearAdMode();
  assert.strictEqual(spy.callCount, 1, 'adstart should not have fired');

  // make sure subsequent adstarts trigger again on exit/re-enter
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');

  this.player.ads.startLinearAdMode();
  assert.strictEqual(spy.callCount, 2, 'adstart should have fired');
});

QUnit.test('calling endLinearAdMode() outside of linear ad mode does not trigger adend', function (assert) {
  var adendSpy;

  adendSpy = sinon.spy();
  this.player.on('adend', adendSpy);

  this.player.ads.endLinearAdMode();
  assert.strictEqual(adendSpy.callCount, 0, 'adend should not have fired right away');

  this.player.trigger('adsready');

  this.player.ads.endLinearAdMode();
  assert.strictEqual(adendSpy.callCount, 0, 'adend should not have fired after adsready');

  this.player.trigger('play');

  this.player.ads.endLinearAdMode();
  assert.strictEqual(adendSpy.callCount, 0, 'adend should not have fired after play');

  this.player.trigger('adtimeout');

  this.player.ads.endLinearAdMode();
  assert.strictEqual(adendSpy.callCount, 0, 'adend should not have fired after adtimeout');

  this.player.ads.startLinearAdMode();

  this.player.ads.endLinearAdMode();
  assert.strictEqual(adendSpy.callCount, 1, 'adend should have fired after preroll');
});

QUnit.test('skipLinearAdMode during ad playback does not trigger adskip', function (assert) {
  var adskipSpy;

  adskipSpy = sinon.spy();
  this.player.on('adskip', adskipSpy);

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();

  this.player.ads.skipLinearAdMode();
  assert.strictEqual(adskipSpy.callCount, 0, 'adskip event should not trigger when skipLinearAdMode is called during an ad');
});

QUnit.test('adsready in content-playback triggers readyforpreroll', function (assert) {
  var spy = sinon.spy();

  this.player.on('readyforpreroll', spy);
  this.player.trigger('loadstart');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('playing'); // entered ContentPlayback
  this.player.trigger('adsready');
  assert.strictEqual(spy.callCount, 1, 'readyforpreroll should have been triggered.');
});

QUnit.test('adsready while preroll content resuming triggers readyforpreroll', function (assert) {
  var spy = sinon.spy();

  this.player.on('readyforpreroll', spy);
  this.player.trigger('loadstart');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  assert.strictEqual(this.player.ads.isContentResuming(), true, 'should be resuming to content');
  this.player.trigger('adsready');
  assert.strictEqual(spy.callCount, 1, 'readyforpreroll should have been triggered.');
});

// ----------------------------------
// Event prefixing during ad playback
// ----------------------------------

QUnit.test('player events during prerolls are prefixed if tech is reused for ad', function (assert) {
  var sawLoadstart = sinon.spy();
  var sawPlaying = sinon.spy();
  var sawPause = sinon.spy();
  var sawEnded = sinon.spy();
  var sawFirstplay = sinon.spy();
  var sawLoadedalldata = sinon.spy();
  var sawAdloadstart = sinon.spy();
  var sawAdpause = sinon.spy();
  var sawAdended = sinon.spy();
  var sawAdfirstplay = sinon.spy();
  var sawAdloadedalldata = sinon.spy();

  // play a preroll
  this.player.on('readyforpreroll', function () {
    this.ads.startLinearAdMode();
  });

  this.player.trigger('play');
  this.player.trigger('loadstart');
  this.player.trigger('adsready');

  this.player.ads.snapshot = {
    currentSrc: 'something'
  };

  // simulate video events that should be prefixed
  this.player.on('loadstart', sawLoadstart);
  this.player.on('playing', sawPlaying);
  this.player.on('pause', sawPause);
  this.player.on('ended', sawEnded);
  this.player.on('firstplay', sawFirstplay);
  this.player.on('loadedalldata', sawLoadedalldata);
  this.player.on('adloadstart', sawAdloadstart);
  this.player.on('adpause', sawAdpause);
  this.player.on('adended', sawAdended);
  this.player.on('adfirstplay', sawAdfirstplay);
  this.player.on('adloadedalldata', sawAdloadedalldata);
  this.player.trigger('firstplay');
  this.player.trigger('loadstart');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');
  this.player.trigger('pause');
  this.player.trigger('ended');
  assert.strictEqual(sawLoadstart.callCount, 0, 'no loadstart fired');
  assert.strictEqual(sawPlaying.callCount, 0, 'no playing fired');
  assert.strictEqual(sawPause.callCount, 0, 'no pause fired');
  assert.strictEqual(sawEnded.callCount, 0, 'no ended fired');
  assert.strictEqual(sawFirstplay.callCount, 0, 'no firstplay fired');
  assert.strictEqual(sawLoadedalldata.callCount, 0, 'no loadedalldata fired');
  assert.strictEqual(sawAdloadstart.callCount, 1, 'adloadstart fired');
  assert.strictEqual(sawAdpause.callCount, 1, 'adpause fired');
  assert.strictEqual(sawAdended.callCount, 1, 'adended fired');
  assert.strictEqual(sawAdfirstplay.callCount, 1, 'adfirstplay fired');
  assert.strictEqual(sawAdloadedalldata.callCount, 1, 'adloadedalldata fired');
});

QUnit.test('player events during midrolls are prefixed if tech is reused for ad', function (assert) {
  var prefixed, unprefixed;

  assert.expect(2);

  prefixed = sinon.spy();
  unprefixed = sinon.spy();

  // play a midroll
  this.player.trigger('play');
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('adtimeout');
  this.player.trigger('playing'); // return to content
  this.player.ads.startLinearAdMode();

  this.player.ads.snapshot = {
    currentSrc: 'something'
  };

  // simulate video events that should be prefixed
  this.player.on(['loadstart', 'playing', 'pause', 'ended', 'firstplay', 'loadedalldata'], unprefixed);
  this.player.on(['adloadstart', 'adpause', 'adended', 'adfirstplay', 'adloadedalldata'], prefixed);
  this.player.trigger('firstplay');
  this.player.trigger('loadstart');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');
  this.player.trigger('pause');
  this.player.trigger('ended');
  assert.strictEqual(unprefixed.callCount, 0, 'no unprefixed events fired');
  assert.strictEqual(prefixed.callCount, 5, 'prefixed events fired');
});

QUnit.test('player events during postrolls are prefixed if tech is reused for ad', function (assert) {
  var prefixed, unprefixed;

  assert.expect(2);

  prefixed = sinon.spy();
  unprefixed = sinon.spy();

  // play a postroll
  this.player.trigger('play');
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('adtimeout');
  this.player.trigger('playing'); // return to content
  this.player.trigger('ended');
  this.player.ads.startLinearAdMode();

  this.player.ads.snapshot = {
    currentSrc: 'something'
  };

  // simulate video events that should be prefixed
  this.player.on(['loadstart', 'playing', 'pause', 'ended', 'firstplay', 'loadedalldata'], unprefixed);
  this.player.on(['adloadstart', 'adpause', 'adended', 'adfirstplay', 'adloadedalldata'], prefixed);
  this.player.trigger('firstplay');
  this.player.trigger('loadstart');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');
  this.player.trigger('pause');
  this.player.trigger('ended');
  assert.strictEqual(unprefixed.callCount, 0, 'no unprefixed events fired');
  assert.strictEqual(prefixed.callCount, 5, 'prefixed events fired');
});

QUnit.test('player events during stitched ads are prefixed', function (assert) {
  var prefixed, unprefixed;

  assert.expect(2);

  prefixed = sinon.spy();
  unprefixed = sinon.spy();

  this.player.ads.stitchedAds(true);

  // play a midroll
  this.player.trigger('play');
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('adtimeout');
  this.player.trigger('playing');
  this.player.ads.startLinearAdMode();

  // simulate video events that should be prefixed
  this.player.on(['loadstart', 'playing', 'pause', 'ended', 'firstplay', 'loadedalldata'], unprefixed);
  this.player.on(['adloadstart', 'adplaying', 'adpause', 'adended', 'adfirstplay', 'adloadedalldata'], prefixed);
  this.player.trigger('firstplay');
  this.player.trigger('loadstart');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');
  this.player.trigger('pause');
  this.player.trigger('ended');
  assert.strictEqual(unprefixed.callCount, 0, 'no unprefixed events fired');
  assert.strictEqual(prefixed.callCount, 6, 'prefixed events fired');
});

QUnit.test('player events during content playback are not prefixed', function (assert) {
  var prefixed, unprefixed;

  assert.expect(3);

  prefixed = sinon.spy();
  unprefixed = sinon.spy();

  // play content
  this.player.trigger('loadstart');
  this.player.trigger('play');
  this.player.trigger('adsready');
  this.player.trigger('adtimeout');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');

  // simulate video events that should not be prefixed
  this.player.on(['seeked', 'playing', 'pause', 'ended', 'firstplay', 'loadedalldata'], unprefixed);
  this.player.on(['adseeked', 'adplaying', 'adpause', 'adended', 'contentended', 'adfirstplay', 'adloadedalldata'], prefixed);
  this.player.trigger('firstplay');
  this.player.trigger('seeked');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');
  this.player.trigger('pause');
  this.player.trigger('ended');
  assert.strictEqual(unprefixed.callCount, 5, 'unprefixed events fired');
  assert.strictEqual(prefixed.callCount, 1, 'prefixed events fired');
  assert.strictEqual(prefixed.getCall(0).args[0].type, 'contentended', 'prefixed the ended event');
});

QUnit.test('startLinearAdMode should only trigger adstart from correct states', function (assert) {

  var adstart = sinon.spy();
  this.player.on('adstart', adstart);

  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 0, 'Before play');

  this.player.trigger('play');

  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 0, 'Before adsready');

  this.player.trigger('adsready');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 1, 'Preroll');

  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 1, 'During preroll playback');

  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');

  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 2, 'Midroll');

  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 2, 'During midroll playback');

  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');

  this.player.trigger('ended');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 3, 'Postroll');

  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 3, 'During postroll playback');

  this.player.ads.endLinearAdMode();
  assert.strictEqual(adstart.callCount, 3, 'Ads done');
});

QUnit.test('ad impl can notify contrib-ads there is no preroll', function (assert) {
  this.player.trigger('loadstart');
  this.player.trigger('nopreroll');
  this.player.trigger('play');
  this.player.trigger('adsready');

  assert.strictEqual(this.player.ads.isInAdMode(), true, 'in ad mode');
  assert.strictEqual(this.player.ads.isContentResuming(), true, 'content is resuming');
});

// Same test as above with different event order because this used to be broken.
QUnit.test('ad impl can notify contrib-ads there is no preroll 2', function (assert) {
  this.player.trigger('loadstart');
  this.player.trigger('nopreroll');
  this.player.trigger('adsready');
  this.player.trigger('play');

  assert.strictEqual(this.player.ads.isInAdMode(), true, 'not in ad mode');
  assert.strictEqual(this.player.ads.isContentResuming(), true, 'content is resuming');
});

QUnit.test('ad impl can notify contrib-ads there is no preroll 3', function (assert) {
  this.player.trigger('loadstart');
  this.player.trigger('play');
  this.player.trigger('nopreroll');
  this.player.trigger('adsready');

  assert.strictEqual(this.player.ads.isInAdMode(), true, 'not in ad mode');
  assert.strictEqual(this.player.ads.isContentResuming(), true, 'content is resuming');
});

QUnit.test('ad impl can notify contrib-ads there is no preroll 4', function (assert) {
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('nopreroll');
  this.player.trigger('play');

  assert.strictEqual(this.player.ads.isInAdMode(), true, 'not in ad mode');
  assert.strictEqual(this.player.ads.isContentResuming(), true, 'content is resuming');
});

QUnit.test('ended event is sent after nopostroll', function (assert) {

  var ended = sinon.spy();

  this.player.on('ended', ended);

  this.player.trigger('loadstart');
  this.player.trigger('nopostroll');
  this.player.trigger('play');
  this.player.trigger('adsready');
  this.player.ads.skipLinearAdMode();
  this.player.trigger('playing');
  this.player.trigger('readyforpostroll');
  this.clock.tick(1);
  assert.ok(ended.calledOnce, 'Ended triggered');
});

QUnit.test('ended event is sent with postroll', function (assert) {

  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.skipLinearAdMode();
  this.player.trigger('playing');

  var ended = sinon.spy();

  this.player.on('ended', ended);

  this.player.trigger('readyforpostroll');

  this.clock.tick(10000);
  assert.ok(ended.calledOnce, 'Ended triggered');
});

QUnit.test('isLive', function (assert) {

  // Make videojs.browser writeable
  videojs.browser = _extends({}, videojs.browser);

  this.player.duration = function () {
    return 0;
  };
  videojs.browser.IOS_VERSION = '8';
  assert.strictEqual(this.player.ads.isLive(this.player), true);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IOS_VERSION = '8';
  assert.strictEqual(this.player.ads.isLive(this.player), false);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IOS_VERSION = '8';
  assert.strictEqual(this.player.ads.isLive(this.player), true);

  this.player.duration = function () {
    return 0;
  };
  videojs.browser.IOS_VERSION = undefined;
  assert.strictEqual(this.player.ads.isLive(this.player), false);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IOS_VERSION = undefined;
  assert.strictEqual(this.player.ads.isLive(this.player), false);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IOS_VERSION = undefined;
  assert.strictEqual(this.player.ads.isLive(this.player), true);
});

QUnit.test('shouldPlayContentBehindAd', function (assert) {

  // Make videojs.browser writeable
  videojs.browser = _extends({}, videojs.browser);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IS_IOS = true;
  videojs.browser.IS_ANDROID = true;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IS_IOS = true;
  videojs.browser.IS_ANDROID = false;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IS_IOS = false;
  videojs.browser.IS_ANDROID = true;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IS_IOS = false;
  videojs.browser.IS_ANDROID = false;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), true);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IS_IOS = true;
  videojs.browser.IS_ANDROID = true;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IS_IOS = true;
  videojs.browser.IS_ANDROID = false;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IS_IOS = false;
  videojs.browser.IS_ANDROID = true;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IS_IOS = false;
  videojs.browser.IS_ANDROID = false;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IS_IOS = false;
  videojs.browser.IS_ANDROID = false;
  try {
    this.player.ads.shouldPlayContentBehindAd();
  } catch (error) {
    assert.strictEqual(error.message, 'shouldPlayContentBehindAd requires a player as a param');
  }

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IS_IOS = false;
  videojs.browser.IS_ANDROID = false;
  this.player.ads.settings.liveCuePoints = false;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);
});

QUnit.test('Check incorrect addition of vjs-live during ad-playback', function (assert) {
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.hasClass('vjs-live'), false, 'We have the correct class');
});

QUnit.test('Check for existence of vjs-live after ad-end for LIVE videos', function (assert) {
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  this.player.duration = function () {
    return Infinity;
  };
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  assert.strictEqual(this.player.ads.isLive(this.player), true, 'Content is LIVE');
  assert.ok(this.player.hasClass('vjs-live'), 'We should be having vjs-live class here');
});

QUnit.test('Plugin state resets after contentchanged', function (assert) {

  assert.equal(this.player.ads.disableNextSnapshotRestore, false);
  assert.equal(this.player.ads._contentHasEnded, false);
  assert.equal(this.player.ads.snapshot, null);
  assert.equal(this.player.ads.snapshot, null);
  assert.equal(this.player.ads.nopreroll_, null);
  assert.equal(this.player.ads.nopostroll_, null);

  this.player.ads.disableNextSnapshotRestore = true;
  this.player.ads._contentHasEnded = true;
  this.player.ads.snapshot = {};
  this.player.ads.nopreroll_ = true;
  this.player.ads.nopostroll_ = true;

  this.player.trigger('contentchanged');

  assert.equal(this.player.ads.disableNextSnapshotRestore, false);
  assert.equal(this.player.ads._contentHasEnded, false);
  assert.equal(this.player.ads.snapshot, null);
  assert.equal(this.player.ads.nopreroll_, false);
  assert.equal(this.player.ads.nopostroll_, false);
});

QUnit.test('Plugin sets adType as expected', function (assert) {

  // adType is unset originally
  assert.strictEqual(this.player.ads.adType, null);

  // before preroll
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.adType, null);
  this.player.trigger('play');
  assert.strictEqual(this.player.ads.adType, null);

  // preroll starts and finishes
  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.ads.adType, 'preroll');
  this.player.ads.endLinearAdMode();
  assert.strictEqual(this.player.ads.adType, null);

  // content is playing, midroll starts
  this.player.trigger('playing');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.ads.adType, 'midroll');

  // midroll ends, content is playing
  this.player.ads.endLinearAdMode();
  assert.strictEqual(this.player.ads.adType, null);
  this.player.trigger('playing');

  // postroll starts
  this.player.trigger('readyforpostroll');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.ads.adType, 'postroll');

  // postroll ends
  this.player.ads.endLinearAdMode();
  assert.strictEqual(this.player.ads.adType, null);

  // reset values
  this.player.trigger('contentchanged');
  assert.strictEqual(this.player.ads.adType, null);

  // check preroll case where play is observed
  this.player.trigger('play');
  assert.strictEqual(this.player.ads.adType, null);
  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.adType, null);
  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.ads.adType, 'preroll');
});

if (videojs.browser.IS_IOS) {
  QUnit.test('Check the textTrackChangeHandler takes effect on iOS', function (assert) {
    var tracks = this.player.textTracks();

    // Since addTextTrack is async, wait for the addtrack event
    tracks.on('addtrack', function () {

      // Confirm the track is added, set the mode to showing
      assert.equal(tracks.length, 1);
      tracks[0].mode = 'showing';
      assert.equal(tracks[0].mode, 'showing', 'Initial state is showing');

      // Start the ad, confirm the track is disabled
      this.player.ads.startLinearAdMode();
      assert.equal(tracks[0].mode, 'disabled', 'Snapshot sets tracks to disabled');

      // Force the mode to showing
      tracks[0].mode = 'showing';
    }.bind(this));

    // The mode should go back to disabled when the change event happens as
    // during ad playback we do not want the content captions to be visible on iOS
    tracks.on('change', function () {
      assert.equal(tracks[0].mode, 'disabled', 'Mode is reset to disabled');

      // End the ad, check the track mode is showing again
      this.player.ads.endLinearAdMode();
      assert.equal(tracks[0].mode, 'showing', 'Mode is restored after ad');
    }.bind(this));

    this.player.trigger('play');
    this.player.trigger('adsready');
    this.player.addTextTrack('captions', 'English', 'en');
  });
}

var sharedHooks = window.sharedModuleHooks();

var timerExists$1 = function timerExists(env, id) {
  return env.clock.timers.hasOwnProperty(id);
};

// Stub mobile browsers to force cancelContentPlay to be used
var fakeVideojs = function fakeVideojs() {
  this.videojs = sinon.stub(videojs, 'browser').get(function () {
    return {
      IS_ANDROID: true,
      IS_IOS: true
    };
  });
};

// Restore original videojs behavior
var restoreVideojs = function restoreVideojs() {
  this.videojs.restore();
};

// Run custom hooks before sharedModuleHooks, as videojs must be
// modified before setting up the player and videojs-contrib-ads
QUnit.module('Cancel Content Play', {
  beforeEach: _.flow(function () {
    this.adsOptions = {};
  }, fakeVideojs, sharedHooks.beforeEach),
  afterEach: _.flow(function () {
    this.adsOptions = null;
  }, restoreVideojs, sharedHooks.afterEach)
});

QUnit.test('pauses to wait for prerolls when the plugin loads BEFORE play', function (assert) {
  var spy = sinon.spy(this.player, 'pause');

  this.player.paused = function () {
    return false;
  };

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.clock.tick(1);
  this.player.trigger('play');
  this.clock.tick(1);

  assert.strictEqual(spy.callCount, 2, 'play attempts are paused');
});

QUnit.test('pauses to wait for prerolls when the plugin loads AFTER play', function (assert) {
  var pauseSpy = sinon.spy(this.player, 'pause');

  this.player.paused = function () {
    return false;
  };

  this.player.trigger('play');
  this.clock.tick(1);
  this.player.trigger('play');
  this.clock.tick(1);
  assert.equal(pauseSpy.callCount, 2, 'play attempts are paused');
});

QUnit.test('stops canceling play events when an ad is playing', function (assert) {
  var setTimeoutSpy = sinon.spy(window, 'setTimeout');
  var pauseSpy = sinon.spy(this.player, 'pause');

  // Throughout this test, we check both that the expected timeout is
  // populated on the `clock` _and_ that `setTimeout` has been called the
  // expected number of times.
  assert.notOk(this.player.ads._cancelledPlay, 'we have not canceled a play event');

  this.player.paused = function () {
    return false;
  };
  this.player.trigger('play');
  assert.strictEqual(setTimeoutSpy.callCount, 1, 'one timer was created (`_prerollTimeout`)');
  assert.ok(timerExists$1(this, this.player.ads._state._timeout), 'preroll timeout exists after play');
  assert.equal(this.player.ads._cancelledPlay, true);

  this.clock.tick(1);
  assert.equal(pauseSpy.callCount, 1);

  this.player.trigger('adsready');
  assert.ok(timerExists$1(this, this.player.ads._state._timeout), 'preroll timeout exists after adsready');

  this.player.ads.startLinearAdMode();
  assert.notOk(timerExists$1(this, this.player.ads._state._timeout), 'preroll timeout no longer exists');

  this.player.trigger('play');
  assert.equal(pauseSpy.callCount, 1, 'pause is not called while in an ad break');

  window.setTimeout.restore();
});

QUnit.test("cancelContentPlay doesn\'t block play in content playback", function (assert) {
  var pauseSpy = sinon.spy(this.player, 'pause');

  this.player.trigger('loadstart');
  this.player.trigger('adscanceled');
  this.player.paused = function () {
    return false;
  };
  this.player.trigger('play');
  assert.strictEqual(pauseSpy.callCount, 1, 'pause should have been called');
  assert.strictEqual(this.player.ads._cancelledPlay, true, 'cancelContentPlay is called while resuming');

  // enters ContentPlayback
  this.player.trigger('playing');
  this.player.trigger('play');

  assert.strictEqual(pauseSpy.callCount, 1, 'pause should not have been called again');
  assert.notOk(this.player.ads._cancelledPlay, 'cancelContentPlay does nothing in content playback');
});

QUnit.test('content is resumed after ads if a user initiated play event is canceled', function (assert) {
  var playSpy = sinon.spy(this.player, 'play');
  var setTimeoutSpy = sinon.spy(window, 'setTimeout');
  var pauseSpy = sinon.spy(this.player, 'pause');

  this.player.paused = function () {
    return false;
  };

  this.player.trigger('play');
  this.player.trigger('adsready');

  assert.strictEqual(setTimeoutSpy.callCount, 1, 'one timer was created (`_prerollTimeout`)');
  assert.ok(timerExists$1(this, this.player.ads._state._timeout), 'preroll timeout exists');
  assert.ok(this.player.ads._cancelledPlay, true, 'play has been canceled');
  assert.ok(pauseSpy.callCount, 1, 'pause was called');

  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  assert.strictEqual(playSpy.callCount, 1, 'play should be called by the snapshot restore');

  this.player.trigger('play');
  assert.ok(pauseSpy.callCount, 1, 'pause was not called again');
});

// Set up contrib-ads options and run custom hooks before sharedModuleHooks, as
// videojs must be modified before setting up the player and videojs-contrib-ads
QUnit.module('Cancel Content Play (w/ Stitched Ads)', {
  beforeEach: _.flow(function () {
    this.adsOptions = {
      stitchedAds: true
    };
  }, fakeVideojs, sharedHooks.beforeEach),
  afterEach: _.flow(function () {
    this.adsOptions = null;
  }, restoreVideojs, sharedHooks.afterEach)
});

QUnit.test('does not pause to wait for prerolls when the plugin loads BEFORE play', function (assert) {
  var spy = sinon.spy(this.player, 'pause');

  this.player.paused = function () {
    return false;
  };

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.clock.tick(1);
  this.player.trigger('play');
  this.clock.tick(1);

  assert.strictEqual(spy.callCount, 0, 'play attempts are not paused');
});

QUnit.test('does not pause to wait for prerolls when the plugin loads AFTER play', function (assert) {
  var pauseSpy = sinon.spy(this.player, 'pause');

  this.player.paused = function () {
    return false;
  };

  this.player.trigger('play');
  this.clock.tick(1);
  this.player.trigger('play');
  this.clock.tick(1);
  assert.equal(pauseSpy.callCount, 0, 'play attempts are not paused');
});

QUnit.module('Cue Metadata Text Tracks', window.sharedModuleHooks({

  beforeEach: function beforeEach() {
    this.tt = {
      player: this.player,
      kind: 'metadata',
      mode: 'hidden',
      id: '1',
      startTime: 1,
      endTime: 2,
      addEventListener: function addEventListener(event, cb) {
        if (event === 'cuechange') {
          cb.apply(this, [this]);
        }
      },
      activeCues: []
    };
  },
  afterEach: function afterEach() {
    this.player.ads.cueTextTracks.getSupportedAdCue = function (player, cue) {
      return cue;
    };
    this.player.ads.cueTextTracks.getCueId = function (cue) {
      return cue.id;
    };
    this.player.ads.cueTextTracks.setMetadataTrackMode = function (track) {
      track.mode = 'hidden';
    };
  }
}));

QUnit.test('runs processMetadataTrack callback as tracks are added', function (assert) {
  var tt = this.tt;
  var processMetadataTrackSpy = sinon.spy();
  var cueTextTracks = this.player.ads.cueTextTracks;

  // Start by adding a text track before processing
  this.player.addRemoteTextTrack(tt);

  cueTextTracks.processMetadataTracks(this.player, processMetadataTrackSpy);
  assert.strictEqual(processMetadataTrackSpy.callCount, 1);

  // add a new text track after initial processing
  this.player.textTracks().trigger({
    track: this.tt,
    type: 'addtrack'
  });
  assert.strictEqual(processMetadataTrackSpy.callCount, 2);
});

QUnit.test('does not call processMetadataTrack callback until tracks available', function (assert) {
  var processMetadataTrackSpy = sinon.spy();
  var cueTextTracks = this.player.ads.cueTextTracks;

  cueTextTracks.processMetadataTracks(this.player, processMetadataTrackSpy);
  assert.strictEqual(processMetadataTrackSpy.callCount, 0);

  var addTrackEvent = {
    track: this.tt,
    type: 'addtrack'
  };
  this.player.textTracks().trigger(addTrackEvent);
  assert.strictEqual(processMetadataTrackSpy.callCount, 1);
});

QUnit.test('setMetadataTrackMode should work when overriden', function (assert) {
  var tt = this.tt;
  var cueTextTracks = this.player.ads.cueTextTracks;

  cueTextTracks.setMetadataTrackMode(tt);
  assert.strictEqual(tt.mode, 'hidden');

  cueTextTracks.setMetadataTrackMode = function (track) {
    track.mode = 'disabled';
  };
  cueTextTracks.setMetadataTrackMode(tt);
  assert.strictEqual(tt.mode, 'disabled');
});

QUnit.test('getSupportedAdCue should work when overriden', function (assert) {
  var cue = {
    startTime: 0,
    endTime: 1
  };

  var cueTextTracks = this.player.ads.cueTextTracks;
  var supportedCue = cueTextTracks.getSupportedAdCue(this.player, cue);
  assert.strictEqual(supportedCue, cue);

  cueTextTracks.getSupportedAdCue = function (player, cue) {
    return -1;
  };
  supportedCue = cueTextTracks.getSupportedAdCue(this.player, cue);
  assert.strictEqual(supportedCue, -1);
});

QUnit.test('getCueId should work when overriden', function (assert) {
  var originalTextTracks = this.player.textTracks;
  var cue = {
    startTime: 0,
    endTime: 1,
    id: 1,
    inner: {
      id: 2
    }
  };
  var tt = this.tt;
  tt.activeCues = [cue];

  this.player.textTracks = function () {
    return {
      length: 1,
      0: tt
    };
  };

  var cueTextTracks = this.player.ads.cueTextTracks;
  var cueId = cueTextTracks.getCueId(cue);
  assert.strictEqual(cueId, 1);

  cueTextTracks.getCueId = function (cue) {
    return cue.inner.id;
  };
  cueId = cueTextTracks.getCueId(cue);
  assert.strictEqual(cueId, 2);

  // Clean Up
  this.player.textTracks = originalTextTracks;
});

QUnit.test('processAdTrack runs processCue callback', function (assert) {
  var processCueSpy = sinon.spy();
  var cueTextTracks = this.player.ads.cueTextTracks;
  var cues = [{
    startTime: 0,
    endTime: 1,
    id: 1,
    callCount: 0
  }];

  cueTextTracks.processAdTrack(this.player, cues, processCueSpy);
  assert.strictEqual(processCueSpy.callCount, 1);

  var processCue = function processCue(player, cueData, cueId, startTime) {
    cueData.callCount += 1;
  };
  cueTextTracks.processAdTrack(this.player, cues, processCue);
  assert.strictEqual(cues[0].callCount, 1);
});

QUnit.test('processAdTrack runs cancelAds callback', function (assert) {
  var cancelAdsSpy = sinon.spy();
  var cueTextTracks = this.player.ads.cueTextTracks;
  var cues = [{
    startTime: 0,
    endTime: 1,
    id: 1,
    callCount: 0
  }];
  var processCue = function processCue(player, cueData, cueId, startTime) {
    return;
  };
  var cancelAds = function cancelAds(player, cueData, cueId, startTime) {
    cueData.callCount += 1;
  };

  cueTextTracks.processAdTrack(this.player, cues, processCue, cancelAdsSpy);
  assert.strictEqual(cancelAdsSpy.callCount, 1);

  cueTextTracks.processAdTrack(this.player, cues, processCue, cancelAds);
  assert.strictEqual(cues[0].callCount, 1);
});

/*
 * Example ad plugin using the videojs-ads plugin.
 *
 * For each content video, this plugin plays one preroll and one midroll.
 * Ad content is chosen randomly from the URLs listed in inventory.json.
 */
(function (window, document, vjs, undefined) {
  "use strict";

  var registerPlugin = vjs.registerPlugin || vjs.plugin;

  /*
   * Register the ad plugin.
   * To initialize for a player, call player.exampleAds().
   *
   * @param {mixed} options Hash of obtions for the exampleAds plugin.
   */
  registerPlugin('exampleAds', function (options) {

    var player = this,


    // example plugin state, may have any of these properties:
    //  - inventory - hypothetical ad inventory, list of URLs to ads
    //  - lastTime - the last time observed during content playback
    //  - adPlaying - whether a linear ad is currently playing
    //  - prerollPlayed - whether we've played a preroll
    //  - midrollPlayed - whether we've played a midroll
    //  - postrollPlayed - whether we've played a postroll
    state = {},


    // just like any other video.js plugin, ad plugins can
    // accept initialization options
    adServerUrl = options && options.adServerUrl || "inventory.json",
        midrollPoint = options && options.midrollPoint || 15,
        playPreroll = options && options.playPreroll !== undefined ? options.playPreroll : true,
        playMidroll = options && options.playMidroll !== undefined ? options.playMidroll : true,
        playPostroll = options && options.playPostroll !== undefined ? options.playPostroll : true,


    // asynchronous method for requesting ad inventory
    requestAds = function requestAds() {

      // reset plugin state
      state = {};

      // fetch ad inventory
      // the 'src' parameter is ignored by the example inventory.json flat file,
      // but this shows how you might send player information along to the ad server.
      var xhr = new XMLHttpRequest();
      xhr.open("GET", adServerUrl + "?src=" + encodeURIComponent(player.currentSrc()));
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          try {
            state.inventory = JSON.parse(xhr.responseText);
            player.trigger('adsready');
          } catch (err) {
            throw new Error('Couldn\'t parse inventory response as JSON');
          }
        }
      };
      xhr.send(null);
    },


    // play an ad, given an opportunity
    playAd = function playAd() {

      // short-circuit if we don't have any ad inventory to play
      if (!state.inventory || state.inventory.length === 0) {
        videojs.log('No inventory to play.');
        return;
      }

      // tell ads plugin we're ready to play our ad
      player.ads.startLinearAdMode();
      state.adPlaying = true;

      // tell videojs to load the ad
      var media = state.inventory[Math.floor(Math.random() * state.inventory.length)];
      player.src(media);
      player.trigger('ads-ad-started');

      // when it's finished
      player.one('adended', function () {
        player.trigger('ads-ad-ended');
        // play your linear ad content, then when it's finished ...
        player.ads.endLinearAdMode();
        state.adPlaying = false;
      });
    };

    // initialize the ads plugin, passing in any relevant options
    player.ads(options);

    // request ads right away
    requestAds();

    player.on('adsready', function () {
      if (!playPreroll) {
        player.trigger('nopreroll');
      }
    });

    // request ad inventory whenever the player gets content to play
    player.on('contentchanged', function () {
      requestAds();
    });

    player.on('readyforpostroll', function () {
      if (!state.postrollPlayed && playPostroll) {
        state.postrollPlayed = true;
        playAd();
      } else {
        player.trigger('nopostroll');
      }
    });

    // play an ad the first time there's a preroll opportunity
    player.on('readyforpreroll', function () {
      if (!state.prerollPlayed && playPreroll) {
        state.prerollPlayed = true;
        playAd();
      }
    });

    // watch for time to pass 15 seconds, then play an ad
    // if we haven't played a midroll already
    player.on('timeupdate', function (event) {

      if (state.midrollPlayed) {
        return;
      }

      var currentTime = player.currentTime(),
          opportunity;

      if ('lastTime' in state) {
        opportunity = currentTime > midrollPoint && state.lastTime < midrollPoint;
      }

      state.lastTime = currentTime;
      if (opportunity && playMidroll) {
        state.midrollPlayed = true;
        playAd();
      }
    });
  });
})(window, document, videojs);

/*
TODO:
* timeupdate, adtimeupdate, contenttimeupdate
* loadstart, adloadstart, contentloadstart
* play, adplay, contentplay
* loadeddata, adloadeddata, contentloadeddata
* loadedmetadata, adloadedmetadata, contentloadedmetadata
*/

QUnit.module('Events and Midrolls', {
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.querySelector('#qunit-fixture');
    this.fixture.appendChild(this.video);

    this.player = videojs$1(this.video);

    this.player.exampleAds({
      'adServerUrl': '/base/test/integration/lib/inventory.json',
      'playPreroll': false,
      'midrollPoint': 1
    });

    this.player.src({
      src: 'http://vjs.zencdn.net/v/oceans.webm',
      type: 'video/webm'
    });
  },

  afterEach: function afterEach() {
    this.player.dispose();
  }
});

QUnit.test('Midrolls', function (assert) {
  var _this = this;

  var done = assert.async();

  var beforeMidroll = true;
  var seenInAdMode = [];
  var seenInContentResuming = [];
  var seenOutsideAdModeBefore = [];
  var seenOutsideAdModeAfter = [];

  this.player.on('adend', function () {
    beforeMidroll = false;
  });

  var events = ['suspend', 'abort', 'error', 'emptied', 'stalled', 'canplay', 'canplaythrough', 'waiting', 'seeking', 'durationchange', 'progress', 'pause', 'ratechange', 'volumechange', 'firstplay', 'suspend', 'playing', 'ended'];

  events = events.concat(events.map(function (e) {
    return 'ad' + e;
  }));

  events = events.concat(events.map(function (e) {
    return 'content' + e;
  }));

  this.player.on(events, function (e) {
    var str = e.type;
    if (_this.player.ads.isInAdMode()) {
      if (_this.player.ads.isContentResuming()) {
        seenInContentResuming.push(str);
      } else {
        seenInAdMode.push(str);
      }
    } else {
      if (beforeMidroll) {
        seenOutsideAdModeBefore.push(str);
      } else {
        seenOutsideAdModeAfter.push(str);
      }
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    videojs$1.log(_this.player.currentTime(), _this.player.currentSrc());
    if (_this.player.currentTime() > 1.1) {

      seenOutsideAdModeBefore.forEach(function (event) {
        assert.ok(!/^ad/.test(event), event + ' has no ad prefix before midroll');
        assert.ok(!/^content/.test(event), event + ' has no content prefix before midroll');
      });

      seenInAdMode.forEach(function (event) {
        assert.ok(/^ad/.test(event), event + ' has ad prefix during midroll');
      });

      seenInContentResuming.forEach(function (event) {
        assert.ok(/^content/.test(event), event + ' has content prefix during midroll');
      });

      seenOutsideAdModeAfter.forEach(function (event) {
        assert.ok(!/^ad/.test(event), event + ' has no ad prefix after midroll');
        assert.ok(!/^content/.test(event), event + ' has no content prefix after midroll');
      });

      done();
    }
  });

  // Seek to right before the midroll
  this.player.one('playing', function () {
    _this.player.currentTime(.9);
  });

  this.player.ready(this.player.play);
});

QUnit.module('Final Events With No Postroll', {
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.querySelector('#qunit-fixture');
    this.fixture.appendChild(this.video);

    this.player = videojs$1(this.video);

    this.player.exampleAds({
      'adServerUrl': '/base/test/integration/lib/inventory.json',
      'playPreroll': false,
      'playMidroll': false,
      'playPostroll': false
    });

    this.player.src({
      src: 'http://vjs.zencdn.net/v/oceans.webm',
      type: 'video/webm'
    });
  },

  afterEach: function afterEach() {
    this.player.dispose();
  }
});

QUnit.test('final ended event with no postroll: just 1', function (assert) {
  var _this = this;

  var done = assert.async();
  var endedEvents = 0;

  // Prevent the test from timing out by making it run faster
  this.player.ads.settings.postrollTimeout = 1;

  this.player.on('ended', function () {
    endedEvents++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.one('ended', function () {
    // Run checks after a pause in case there are multiple ended events.
    setTimeout(function () {
      assert.equal(endedEvents, 1, 'exactly one ended with no postroll');
      done();
    }, 1000);
  });

  // Seek to end once we're ready so postroll can play quickly
  this.player.one('playing', function () {
    _this.player.currentTime(46);
  });

  this.player.ready(this.player.play);
});

QUnit.module('Initial Events With No Preroll', {
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.querySelector('#qunit-fixture');
    this.fixture.appendChild(this.video);

    this.player = videojs$1(this.video);

    this.player.exampleAds({
      'adServerUrl': '/base/test/integration/lib/inventory.json',
      'playPreroll': false,
      'playMidroll': false
    });

    this.player.src({
      src: 'http://vjs.zencdn.net/v/oceans.webm',
      type: 'video/webm'
    });
  },

  afterEach: function afterEach() {
    this.player.dispose();
  }
});

QUnit.test('initial play event with no preroll: one please', function (assert) {
  var _this = this;

  var done = assert.async();

  var playEvents = 0;

  this.player.on('play', function () {
    playEvents++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this.player.currentTime() > 1) {
      assert.equal(playEvents, 1, '1 play event');
      done();
    }
  });

  this.player.ready(this.player.play);
});

QUnit.test('initial playing event with no preroll: 1+', function (assert) {
  var _this2 = this;

  var done = assert.async();

  var playingEvents = 0;

  this.player.on('playing', function () {
    playingEvents++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this2.player.currentTime() > 1) {
      assert.ok(playingEvents >= 1, '1+ playing events');
      done();
    }
  });

  this.player.ready(this.player.play);
});

QUnit.test('no ended event at start if video with no preroll', function (assert) {
  var _this3 = this;

  var done = assert.async();

  var endedEvents = 0;

  this.player.on('ended', function () {
    endedEvents++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this3.player.currentTime() > 1) {
      assert.equal(endedEvents, 0, 'no ended events');
      done();
    }
  });

  this.player.ready(this.player.play);
});

QUnit.test('initial loadstart event with no preroll: one please', function (assert) {
  var _this4 = this;

  var done = assert.async();

  var loadstartEvents = 0;

  this.player.on('loadstart', function () {
    loadstartEvents++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this4.player.currentTime() > 1) {
      assert.equal(loadstartEvents, 1, '1 loadstart event');
      done();
    }
  });

  this.player.ready(this.player.play);
});

/*
TODO:
* timeupdate, adtimeupdate, contenttimeupdate
* loadstart, adloadstart, contentloadstart
* play, adplay, contentplay
* contentended
* loadeddata, adloadeddata, contentloadeddata
* loadedmetadata, adloadedmetadata, contentloadedmetadata
*/

QUnit.module('Events and Postrolls', {
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.querySelector('#qunit-fixture');
    this.fixture.appendChild(this.video);

    this.player = videojs$1(this.video);

    this.player.exampleAds({
      'adServerUrl': '/base/test/integration/lib/inventory.json',
      'playPreroll': false,
      'playMidroll': false
    });

    this.player.src({
      src: 'http://vjs.zencdn.net/v/oceans.webm',
      type: 'video/webm'
    });
  },

  afterEach: function afterEach() {
    this.player.dispose();
  }
});

QUnit.test('ended event and postrolls: 0 before postroll, 1 after', function (assert) {
  var _this = this;

  var done = assert.async();

  var beforePostroll = true;
  var endedBeforePostroll = 0;
  var endedAfterPostroll = 0;

  this.player.on('adend', function () {
    beforePostroll = false;
  });

  this.player.on('ended', function () {
    if (beforePostroll) {
      endedBeforePostroll++;
    } else {
      endedAfterPostroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.one('ended', function () {
    if (beforePostroll) {
      assert.ok(false, 'ended before postroll!');
    }
    // Run checks after a pause in case there are multiple ended events.
    setTimeout(function () {
      assert.equal(endedBeforePostroll, 0, 'no ended before postroll');
      assert.equal(endedAfterPostroll, 1, 'exactly one ended after postroll');
      done();
    }, 1000);
  });

  this.player.ready(function () {
    _this.player.play();
    _this.player.currentTime(46);
  });
});

QUnit.test('Event prefixing and postrolls', function (assert) {
  var _this2 = this;

  var done = assert.async();

  var beforePostroll = true;
  var seenInAdMode = [];
  var seenInContentResuming = [];
  var seenOutsideAdModeBefore = [];
  var seenOutsideAdModeAfter = [];

  this.player.on('adend', function () {
    beforePostroll = false;
  });

  var events = ['suspend', 'abort', 'error', 'emptied', 'stalled', 'canplay', 'canplaythrough', 'waiting', 'seeking', 'durationchange', 'progress', 'pause', 'ratechange', 'volumechange', 'firstplay', 'suspend', 'playing', 'ended'];

  events = events.concat(events.map(function (e) {
    return 'ad' + e;
  }));

  events = events.concat(events.map(function (e) {
    return 'content' + e;
  }));

  this.player.on(events, function (e) {
    if (e.type === 'contentended') {
      return;
    }
    var str = e.type;
    if (_this2.player.ads.isInAdMode()) {
      if (_this2.player.ads.isContentResuming()) {
        seenInContentResuming.push(str);
      } else {
        seenInAdMode.push(str);
      }
    } else {
      if (beforePostroll) {
        seenOutsideAdModeBefore.push(str);
      } else {
        seenOutsideAdModeAfter.push(str);
      }
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('ended', function () {

    seenOutsideAdModeBefore.forEach(function (event) {
      assert.ok(!/^ad/.test(event), event + ' has no ad prefix before postroll');
      assert.ok(!/^content/.test(event), event + ' has no content prefix before postroll');
    });

    seenInAdMode.forEach(function (event) {
      assert.ok(/^ad/.test(event), event + ' has ad prefix during postroll');
    });

    seenInContentResuming.forEach(function (event) {
      assert.ok(/^content/.test(event), event + ' has content prefix during postroll');
    });

    seenOutsideAdModeAfter.forEach(function (event) {
      assert.ok(!/^ad/.test(event), event + ' has no ad prefix after postroll');
      assert.ok(!/^content/.test(event), event + ' has no content prefix after postroll');
    });

    done();
  });

  // Seek to end once we're ready so postroll can play quickly
  this.player.one('playing', function () {
    _this2.player.currentTime(46);
  });

  this.player.ready(this.player.play);
});

/*
TODO:
* adplay, contentplay
* adplaying, contentplaying
* adloadstart, contentloadstart
* adended
* adloadeddata, contentloadeddata
* adloadedmetadata, contentloadedmetadata
*/

QUnit.module('Events and Prerolls', {
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.querySelector('#qunit-fixture');
    this.fixture.appendChild(this.video);

    this.player = videojs$1(this.video);

    this.player.exampleAds({
      'adServerUrl': '/base/test/integration/lib/inventory.json'
    });

    this.player.src({
      src: 'http://vjs.zencdn.net/v/oceans.webm',
      type: 'video/webm'
    });
  },

  afterEach: function afterEach() {
    this.player.dispose();
  }
});

QUnit.test('playing event and prerolls: 0 before preroll, 1+ after', function (assert) {
  var _this = this;

  var done = assert.async();

  var beforePreroll = true;
  var playingBeforePreroll = 0;
  var playingAfterPreroll = 0;

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  this.player.on('playing', function () {
    if (beforePreroll) {
      playingBeforePreroll++;
    } else {
      playingAfterPreroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this.player.currentTime() > 1) {
      assert.equal(playingBeforePreroll, 0, 'no playing before preroll');
      assert.ok(playingAfterPreroll > 0, 'playing after preroll');
      done();
    }
  });

  this.player.ready(this.player.play);
});

QUnit.test('ended event and prerolls: not even once', function (assert) {
  var _this2 = this;

  var done = assert.async();

  var ended = 0;

  this.player.on('ended', function () {
    ended++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this2.player.currentTime() > 1) {
      assert.equal(ended, 0, 'no ended events');
      done();
    }
  });

  this.player.ready(this.player.play);
});

QUnit.test('loadstart event and prerolls: 1 before preroll, 0 after', function (assert) {
  var _this3 = this;

  var done = assert.async();

  var beforePreroll = true;
  var loadstartBeforePreroll = 0;
  var loadstartAfterPreroll = 0;

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  this.player.on('loadstart', function (e) {
    if (beforePreroll) {
      loadstartBeforePreroll++;
    } else {
      loadstartAfterPreroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function (e) {
    if (_this3.player.currentTime() > 1) {
      assert.equal(loadstartBeforePreroll, 1, 'loadstart before preroll');
      assert.equal(loadstartAfterPreroll, 0, 'loadstart after preroll');
      done();
    }
  });

  this.player.ready(this.player.play);
});

QUnit.test('loadedmetadata event and prerolls: 1 before preroll, 0 after', function (assert) {
  var _this4 = this;

  var done = assert.async();

  var beforePreroll = true;
  var loadedmetadataBeforePreroll = 0;
  var loadedmetadataAfterPreroll = 0;

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  this.player.on('loadedmetadata', function (e) {
    if (beforePreroll) {
      loadedmetadataBeforePreroll++;
    } else {
      loadedmetadataAfterPreroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function (e) {
    if (_this4.player.currentTime() > 1) {
      assert.equal(loadedmetadataBeforePreroll, 1, 'loadedmetadata before preroll');
      assert.equal(loadedmetadataAfterPreroll, 0, 'loadedmetadata after preroll');
      done();
    }
  });

  this.player.ready(this.player.play);
});

QUnit.test('loadeddata event and prerolls: 1 before preroll, 0 after', function (assert) {
  var _this5 = this;

  var done = assert.async();

  var beforePreroll = true;
  var loadeddataBeforePreroll = 0;
  var loadeddataAfterPreroll = 0;

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  this.player.on('loadeddata', function (e) {
    if (beforePreroll) {
      loadeddataBeforePreroll++;
    } else {
      loadeddataAfterPreroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function (e) {
    if (_this5.player.currentTime() > 1) {
      assert.equal(loadeddataBeforePreroll, 1, 'loadeddata before preroll');
      assert.equal(loadeddataAfterPreroll, 0, 'loadeddata after preroll');
      done();
    }
  });

  this.player.ready(this.player.play);
});

QUnit.test('play event and prerolls: 1 before preroll, 0 after', function (assert) {
  var _this6 = this;

  var done = assert.async();

  var beforePreroll = true;
  var playBeforePreroll = 0;
  var playAfterPreroll = 0;

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  this.player.on('play', function () {
    if (beforePreroll) {
      playBeforePreroll++;
    } else {
      playAfterPreroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this6.player.currentTime() > 1) {
      assert.equal(playBeforePreroll, 1, 'play before preroll'); // 2
      assert.equal(playAfterPreroll, 0, 'play after preroll');
      done();
    }
  });

  this.player.ready(this.player.play);
});

QUnit.test('Event prefixing and prerolls', function (assert) {
  var _this7 = this;

  var done = assert.async();

  var beforePreroll = true;
  var seenInAdMode = [];
  var seenInContentResuming = [];
  var seenOutsideAdModeBefore = [];
  var seenOutsideAdModeAfter = [];

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  var events = ['suspend', 'abort', 'error', 'emptied', 'stalled', 'canplay', 'canplaythrough', 'waiting', 'seeking', 'durationchange', 'timeupdate', 'progress', 'pause', 'ratechange', 'volumechange', 'firstplay', 'suspend'];

  events = events.concat(events.map(function (e) {
    return 'ad' + e;
  }));

  events = events.concat(events.map(function (e) {
    return 'content' + e;
  }));

  this.player.on(events, function (e) {
    var str = e.type;
    if (_this7.player.ads.isInAdMode()) {
      if (_this7.player.ads.isContentResuming()) {
        seenInContentResuming.push(str);
      } else {
        seenInAdMode.push(str);
      }
    } else {
      if (beforePreroll) {
        seenOutsideAdModeBefore.push(str);
      } else {
        seenOutsideAdModeAfter.push(str);
      }
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this7.player.currentTime() > 0) {

      seenOutsideAdModeBefore.forEach(function (event) {
        assert.ok(!/^ad/.test(event), event + ' has no ad prefix before preroll');
        assert.ok(!/^content/.test(event), event + ' has no content prefix before preroll');
      });

      seenInAdMode.forEach(function (event) {
        assert.ok(/^ad/.test(event), event + ' has ad prefix during preroll');
      });

      seenInContentResuming.forEach(function (event) {
        assert.ok(/^content/.test(event), event + ' has content prefix during preroll');
      });

      seenOutsideAdModeAfter.forEach(function (event) {
        assert.ok(!/^ad/.test(event), event + ' has no ad prefix after preroll');
        assert.ok(!/^content/.test(event), event + ' has no content prefix after preroll');
      });

      done();
    }
  });

  this.player.ready(this.player.play);
});

QUnit.module('Ad Macros', window.sharedModuleHooks({}));

QUnit.test('player.id', function (assert) {
  this.player.options_['data-player'] = '12345';
  var result = this.player.ads.adMacroReplacement('{player.id}');

  assert.equal(result, '12345');
});

QUnit.test('mediainfo', function (assert) {
  this.player.mediainfo = {
    id: 1,
    name: 2,
    description: 3,
    tags: 4,
    reference_id: 5,
    duration: 6,
    ad_keys: 7
  };
  var result = this.player.ads.adMacroReplacement('{mediainfo.id}' + '{mediainfo.name}' + '{mediainfo.description}' + '{mediainfo.tags}' + '{mediainfo.reference_id}' + '{mediainfo.duration}' + '{mediainfo.ad_keys}');

  assert.equal(result, '1234567');
});

QUnit.test('player.duration', function (assert) {
  this.player.duration = function () {
    return 5;
  };
  var result = this.player.ads.adMacroReplacement('{player.duration}');

  assert.equal(result, 5);
});

QUnit.test('timestamp', function (assert) {
  this.player.duration = function () {
    return 5;
  };
  var result = this.player.ads.adMacroReplacement('{timestamp}');

  assert.equal(result, new Date().getTime());
});

QUnit.test('document.referrer', function (assert) {
  var result = this.player.ads.adMacroReplacement('{document.referrer}');

  assert.equal(result, document.referrer, '"' + result + '" was the document.referrer');
});

QUnit.test('window.location.href', function (assert) {
  var result = this.player.ads.adMacroReplacement('{window.location.href}');

  assert.equal(result, window.location.href, '"' + result + '" was the window.location.href');
});

QUnit.test('random', function (assert) {
  var result = this.player.ads.adMacroReplacement('{random}');

  assert.ok(result.match(/^\d+$/), '"' + result + '" is a random number');
});

QUnit.test('mediainfo.custom_fields', function (assert) {
  this.player.mediainfo = {
    custom_fields: {
      dog: 1,
      cat: 2,
      guinea_pig: 3
    },
    customFields: {
      dog: 1,
      cat: 2,
      guinea_pig: 3
    }
  };
  var result = this.player.ads.adMacroReplacement('{mediainfo.custom_fields.dog}' + '{mediainfo.custom_fields.cat}' + '{mediainfo.custom_fields.guinea_pig}' + '{mediainfo.customFields.dog}' + '{mediainfo.customFields.cat}' + '{mediainfo.customFields.guinea_pig}');

  assert.equal(result, '123123');
});

QUnit.test('pageVariables', function (assert) {

  window.animal = {
    dog: 'Old Buddy',
    cat: {
      maineCoon: 'Huge the Cat',
      champion: {
        name: 'Champ'
      }
    }
  };
  window.bird = null;
  window.isAwesome = true;
  window.foo = function () {};
  window.bar = {};

  var result = this.player.ads.adMacroReplacement('Number: {pageVariable.scrollX}, ' + 'Boolean: {pageVariable.isAwesome}, ' + 'Null: {pageVariable.bird}, ' + 'Undefined: {pageVariable.thisDoesNotExist}, ' + 'Function: {pageVariable.foo}, ' + 'Object: {pageVariable.bar}, ' + 'Nested 2x: {pageVariable.animal.dog}, ' + 'Nested 3x: {pageVariable.animal.cat.maineCoon}, ' + 'Nested 4x: {pageVariable.animal.cat.champion.name}');

  assert.equal(result, 'Number: 0, ' + 'Boolean: true, ' + 'Null: null, ' + 'Undefined: , ' + 'Function: , ' + 'Object: , ' + 'Nested 2x: Old Buddy, ' + 'Nested 3x: Huge the Cat, ' + 'Nested 4x: Champ');
});

QUnit.test('uriEncode', function (assert) {
  this.player.mediainfo = {
    custom_fields: {
      urlParam: '? &'
    }
  };
  window.foo = '& ?';
  var result = this.player.ads.adMacroReplacement('{mediainfo.custom_fields.urlParam}{pageVariable.foo}', true);

  assert.equal(result, '%3F%20%26%26%20%3F');
});

QUnit.test('customMacros', function (assert) {
  var result = this.player.ads.adMacroReplacement('The sky is {skyColor}. {exclamation}!', false, {
    '{skyColor}': 'blue',
    '{exclamation}': 'Hooray'
  });

  assert.equal(result, 'The sky is blue. Hooray!');
});

QUnit.test('default values', function (assert) {
  this.player.mediainfo = {
    customFields: {
      set: 1
    },
    reference_id: 'abc'
  };
  window.testvar1 = 'a';

  assert.equal(this.player.ads.adMacroReplacement('{mediainfo.customFields.set=other}'), '1', 'custom fields: set value is not replaced by default');

  assert.equal(this.player.ads.adMacroReplacement('{mediainfo.customFields.unsset=2}'), '2', 'custom fields: unset value is replaced by default');

  assert.equal(this.player.ads.adMacroReplacement('{mediainfo.ad_keys=key=value}'), 'key=value', 'equals in default value preserved');

  assert.equal(this.player.ads.adMacroReplacement('{mediainfo.reference_id=Other}'), 'abc', 'mediainfo: set value is not replaced by default');

  assert.equal(this.player.ads.adMacroReplacement('{mediainfo.description=xyz}'), 'xyz', 'mediainfo: unset value is replaced by default');

  assert.equal(this.player.ads.adMacroReplacement('{pageVariable.testvar1=b}'), 'a', 'pageVariable: set value is not replaced by default');

  assert.equal(this.player.ads.adMacroReplacement('{pageVariable.testvar2=c}'), 'c', 'pageVariable: unset value is replaced by default');
});

QUnit.module('Integration: play middleware', {
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.querySelector('#qunit-fixture');
    this.fixture.appendChild(this.video);

    this.player = videojs$1(this.video);

    this.player.exampleAds({
      'adServerUrl': '/base/test/integration/lib/inventory.json'
    });
  },

  afterEach: function afterEach() {
    this.player.dispose();
  }
});

QUnit.test('the `_playRequested` flag is set on the first play request', function (assert) {
  var _this = this;

  var done = assert.async();

  this.player.src({
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  });

  // When the preroll starts
  this.player.on('adstart', function () {
    assert.strictEqual(_this.player.ads._playRequested, true, '_playRequested is true when the play method is used');
    done();
  });

  // If there wasn't an ad
  this.player.on('timeupdate', function () {
    if (_this.player.currentTime() > 0) {
      assert.strictEqual(_this.player.ads._playRequested, true, '_playRequested is true when the play method is used');
      done();
    }
  });

  this.player.ready(this.player.play);
});

QUnit.test('blocks calls to play to wait for prerolls if adsready BEFORE play', function (assert) {
  var _this2 = this;

  var done = assert.async();
  var techPlaySpy = sinon.spy(this.video, 'play');
  var playEventSpy = sinon.spy();
  var seenAdsReady = false;

  this.player.on('play', playEventSpy);
  this.player.on('adsready', function () {
    seenAdsReady = true;
  });

  // When the preroll starts
  this.player.on('adstart', function () {
    assert.strictEqual(techPlaySpy.callCount, 0, "tech play shouldn't be called while waiting for prerolls");
    assert.strictEqual(playEventSpy.callCount, 1, 'play event should be triggered');
    done();
  });

  // Once we are in content
  this.player.on('timeupdate', function () {
    if (_this2.player.currentTime() > 0) {
      assert.strictEqual(techPlaySpy.callCount, 0, "tech play shouldn't be called while waiting for prerolls");
      assert.strictEqual(playEventSpy.callCount, 1, 'play event should be triggered');
      done();
    }
  });

  this.player.on(['error', 'aderror', 'adtimeout'], function () {
    assert.ok(false, 'no errors, or adtimeout');
    done();
  });

  this.player.src({
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  });

  this.player.ready(function () {
    if (seenAdsReady) {
      _this2.player.play();
    } else {
      _this2.player.on('adsready', _this2.player.play);
    }
  });
});

QUnit.test('stops blocking play when an ad is playing', function (assert) {
  var _this3 = this;

  var done = assert.async();

  this.player.on('adstart', function () {
    assert.strictEqual(_this3.player.ads._shouldBlockPlay, true);
  });

  // Wait for the ad to start playing
  this.player.on('ads-ad-started', function () {
    assert.strictEqual(_this3.player.ads._shouldBlockPlay, false, 'should stop blocking once in an adbreak');
    done();
  });

  this.player.src({
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  });

  this.player.ready(this.player.play);
});

QUnit.test("playMiddleware doesn\'t block play in content playback", function (assert) {
  var _this4 = this;

  var done = assert.async();

  this.player.on('adstart', function () {
    assert.strictEqual(_this4.player.ads._shouldBlockPlay, true);
  });

  // Wait for the ad to start playing
  this.player.on('timeupdate', function () {
    if (_this4.player.currentTime() > 0) {
      assert.strictEqual(_this4.player.ads._shouldBlockPlay, false, 'should stop blocking in content');
      done();
    }
  });

  this.player.src({
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  });

  this.player.ready(this.player.play);
});

QUnit.test("don't trigger play event if another middleware terminates", function (assert) {
  var done = assert.async();
  var fixture = document.querySelector('#qunit-fixture');
  var vid = document.createElement('video');
  var playSpy = sinon.spy();

  var shouldTerminate = true;
  var anotherMiddleware = function anotherMiddleware(player) {
    return {
      setSource: function setSource(srcObj, next) {
        next(null, srcObj);
      },
      callPlay: function callPlay() {
        if (shouldTerminate === true) {
          shouldTerminate = false;
          return videojs$1.middleware.TERMINATOR;
        }
      },
      play: function play(terminated, value) {}
    };
  };
  var localPlayer = void 0;

  // Register the other middleware
  videojs$1.use('video/webm', anotherMiddleware);

  // Don't use the shared player, setup new localPlayer
  fixture.appendChild(vid);
  localPlayer = videojs$1(vid);

  // Setup before example integration
  localPlayer.on('nopreroll', function () {
    localPlayer.ready(localPlayer.play);
  });

  // Don't play preroll ads
  localPlayer.exampleAds({
    'adServerUrl': '/base/test/integration/lib/inventory.json',
    playPreroll: false
  });

  localPlayer.on('play', playSpy);

  // Wait for the middleware to run
  localPlayer.setTimeout(function () {
    assert.strictEqual(localPlayer.ads._playBlocked, false, 'play should not have been blocked');
    assert.strictEqual(playSpy.callCount, 0, 'play event should not be triggered');
    done();
  }, 1);

  localPlayer.src({
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  });
});

/*
The snapshot feature is responsible for saving the player state before an ad, then
restoring the player state after an ad.
*/

var tryToResumeTimeout_ = void 0;

/*
 * Returns an object that captures the portions of player state relevant to
 * video playback. The result of this function can be passed to
 * restorePlayerSnapshot with a player to return the player to the state it
 * was in when this function was invoked.
 * @param {Object} player The videojs player object
 */
function getPlayerSnapshot(player) {
  var currentTime = void 0;

  if (videojs$1.browser.IS_IOS && player.ads.isLive(player)) {
    // Record how far behind live we are
    if (player.seekable().length > 0) {
      currentTime = player.currentTime() - player.seekable().end(0);
    } else {
      currentTime = player.currentTime();
    }
  } else {
    currentTime = player.currentTime();
  }

  var tech = player.$('.vjs-tech');
  var tracks = player.textTracks ? player.textTracks() : [];
  var suppressedTracks = [];
  var snapshotObject = {
    ended: player.ended(),
    currentSrc: player.currentSrc(),
    sources: player.currentSources(),
    src: player.tech_.src(),
    currentTime: currentTime,
    type: player.currentType()
  };

  if (tech) {
    snapshotObject.style = tech.getAttribute('style');
  }

  for (var i = 0; i < tracks.length; i++) {
    var track = tracks[i];

    suppressedTracks.push({
      track: track,
      mode: track.mode
    });
    track.mode = 'disabled';
  }
  snapshotObject.suppressedTracks = suppressedTracks;

  return snapshotObject;
}

/*
 * Attempts to modify the specified player so that its state is equivalent to
 * the state of the snapshot.
 * @param {Object} player - the videojs player object
 * @param {Object} snapshotObject - the player state to apply
 */
function restorePlayerSnapshot(player, callback) {
  var snapshotObject = player.ads.snapshot;

  if (callback === undefined) {
    callback = function callback() {};
  }

  if (player.ads.disableNextSnapshotRestore === true) {
    player.ads.disableNextSnapshotRestore = false;
    delete player.ads.snapshot;
    callback();
    return;
  }

  // The playback tech
  var tech = player.$('.vjs-tech');

  // the number of[ remaining attempts to restore the snapshot
  var attempts = 20;

  var suppressedTracks = snapshotObject.suppressedTracks;

  var trackSnapshot = void 0;
  var restoreTracks = function restoreTracks() {
    for (var i = 0; i < suppressedTracks.length; i++) {
      trackSnapshot = suppressedTracks[i];
      trackSnapshot.track.mode = trackSnapshot.mode;
    }
  };

  // Finish restoring the playback state.
  // This only happens if the content video element was reused for ad playback.
  var resume = function resume() {
    var currentTime = void 0;

    // Live video on iOS has special logic to try to seek to the right place after
    // an ad.
    if (videojs$1.browser.IS_IOS && player.ads.isLive(player)) {
      if (snapshotObject.currentTime < 0) {
        // Playback was behind real time, so seek backwards to match
        if (player.seekable().length > 0) {
          currentTime = player.seekable().end(0) + snapshotObject.currentTime;
        } else {
          currentTime = player.currentTime();
        }
        player.currentTime(currentTime);
      }

      // iOS live play after restore if player was paused (would not be paused if
      // ad played muted behind ad)
      if (player.paused()) {
        var playPromise = player.play();

        if (playPromise && playPromise['catch']) {
          playPromise['catch'](function (error) {
            videojs$1.log.warn('Play promise rejected in IOS snapshot resume', error);
          });
        }
      }

      // Restore the video position after an ad.
      // We check snapshotObject.ended because the content starts at the beginning again
      // after being restored.
    } else if (snapshotObject.ended) {
      // For postrolls, seek to the player's current duration.
      // It could be different from the snapshot's currentTime due to
      // inaccuracy in HLS.
      player.currentTime(player.duration());
    } else {
      // Prerolls and midrolls, just seek to the player time before the ad.
      player.currentTime(snapshotObject.currentTime);
      var _playPromise = player.play();

      if (_playPromise && _playPromise['catch']) {
        _playPromise['catch'](function (error) {
          videojs$1.log.warn('Play promise rejected in snapshot resume', error);
        });
      }
    }

    // if we added autoplay to force content loading on iOS, remove it now
    // that it has served its purpose
    if (player.ads.shouldRemoveAutoplay_) {
      player.autoplay(false);
      player.ads.shouldRemoveAutoplay_ = false;
    }
  };

  // Determine if the video element has loaded enough of the snapshot source
  // to be ready to apply the rest of the state.
  // This only happens if the content video element was reused for ad playback.
  var tryToResume = function tryToResume() {

    // tryToResume can either have been called through the `contentcanplay`
    // event or fired through setTimeout.
    // When tryToResume is called, we should make sure to clear out the other
    // way it could've been called by removing the listener and clearing out
    // the timeout.
    player.off('contentcanplay', tryToResume);
    if (tryToResumeTimeout_) {
      player.clearTimeout(tryToResumeTimeout_);
    }

    // Tech may have changed depending on the differences in sources of the
    // original video and that of the ad
    tech = player.el().querySelector('.vjs-tech');

    if (tech.readyState > 1) {
      // some browsers and media aren't "seekable".
      // readyState greater than 1 allows for seeking without exceptions
      return resume();
    }

    if (tech.seekable === undefined) {
      // if the tech doesn't expose the seekable time ranges, try to
      // resume playback immediately
      return resume();
    }

    if (tech.seekable.length > 0) {
      // if some period of the video is seekable, resume playback
      return resume();
    }

    // delay a bit and then check again unless we're out of attempts
    if (attempts--) {
      player.setTimeout(tryToResume, 50);
    } else {
      try {
        resume();
      } catch (e) {
        videojs$1.log.warn('Failed to resume the content after an advertisement', e);
      }
    }
  };

  if ('style' in snapshotObject) {
    // overwrite all css style properties to restore state precisely
    tech.setAttribute('style', snapshotObject.style || '');
  }

  // Determine whether the player needs to be restored to its state
  // before ad playback began. With a custom ad display or burned-in
  // ads, the content player state hasn't been modified and so no
  // restoration is required

  if (player.ads.videoElementRecycled()) {
    // Snapshot restore is done, so now we're really finished.
    player.one('resumeended', function () {
      delete player.ads.snapshot;
      callback();
    });

    // on ios7, fiddling with textTracks too early will cause safari to crash
    player.one('contentloadedmetadata', restoreTracks);

    // adding autoplay guarantees that Safari will load the content so we can
    // seek back to the correct time after ads
    if (videojs$1.browser.IS_IOS && !player.autoplay()) {
      player.autoplay(true);

      // if we get here, the player was not originally configured to autoplay,
      // so we should remove it after it has served its purpose
      player.ads.shouldRemoveAutoplay_ = true;
    }

    // if the src changed for ad playback, reset it
    player.src(snapshotObject.sources);

    // and then resume from the snapshots time once the original src has loaded
    // in some browsers (firefox) `canplay` may not fire correctly.
    // Reace the `canplay` event with a timeout.
    player.one('contentcanplay', tryToResume);
    tryToResumeTimeout_ = player.setTimeout(tryToResume, 2000);
  } else {
    // if we didn't change the src, just restore the tracks
    restoreTracks();

    // we don't need to check snapshotObject.ended here because the content video
    // element wasn't recycled
    if (!player.ended()) {
      // the src didn't change and this wasn't a postroll
      // just resume playback at the current time.
      var playPromise = player.play();

      if (playPromise && playPromise['catch']) {
        playPromise['catch'](function (error) {
          videojs$1.log.warn('Play promise rejected in snapshot restore', error);
        });
      }
    }

    // snapshot restore is complete
    delete player.ads.snapshot;
    callback();
  }
}

QUnit.module('Video Snapshot', window.sharedModuleHooks({

  beforeEach: function beforeEach() {
    var captionTrack = document.createElement('track');
    var otherTrack = document.createElement('track');

    captionTrack.setAttribute('kind', 'captions');
    captionTrack.setAttribute('src', '/base/test/integration/lib/testcaption.vtt');
    otherTrack.setAttribute('src', '/base/test/integration/lib/testcaption.vtt');
    this.video.appendChild(captionTrack);
    this.video.appendChild(otherTrack);

    this.player.ended = function () {
      return false;
    };
  }
}));

QUnit.test('restores the original video src after ads', function (assert) {
  var originalSrc = {
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  };

  this.player.src(originalSrc);

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  this.player.src({
    src: '//example.com/ad.webm',
    type: 'video/webm'
  });
  this.player.ads.endLinearAdMode();
  assert.strictEqual(this.player.currentSrc(), originalSrc.src, 'the original src is restored');
});

QUnit.test('waits for the video to become seekable before restoring the time', function (assert) {
  var setTimeoutSpy;

  assert.expect(2);

  this.player.trigger('adsready');
  this.player.trigger('play');

  // the video plays to time 100
  setTimeoutSpy = sinon.spy(window, 'setTimeout');
  this.video.currentTime = 100;
  this.player.ads.startLinearAdMode();
  this.player.src({
    src: '//example.com/ad.webm',
    type: 'video/webm'
  });

  // the ad resets the current time
  this.video.currentTime = 0;
  this.player.ads.endLinearAdMode();
  setTimeoutSpy.reset(); // we call setTimeout an extra time restorePlayerSnapshot
  this.player.trigger('canplay');
  assert.strictEqual(setTimeoutSpy.callCount, 1, 'restoring the time should be delayed');
  assert.strictEqual(this.video.currentTime, 0, 'currentTime is not modified');
  window.setTimeout.restore();
});

QUnit.test('the current time is restored at the end of an ad', function (assert) {
  assert.expect(1);

  this.player.trigger('adsready');
  this.video.currentTime = 100;
  this.player.trigger('play');

  // the video plays to time 100
  this.player.ads.startLinearAdMode();
  this.player.src({
    src: '//example.com/ad.webm',
    type: 'video/webm'
  });

  // the ad resets the current time
  this.video.currentTime = 0;
  this.player.ads.endLinearAdMode();
  this.player.trigger('canplay');
  this.clock.tick(1000);
  assert.strictEqual(this.video.currentTime, 100, 'currentTime was restored');
});

QUnit.test('only restores the player snapshot if the src changed', function (assert) {
  var playSpy, srcSpy, currentTimeSpy;

  this.player.trigger('adsready');
  this.player.trigger('play');
  playSpy = sinon.spy(this.player, 'play');
  srcSpy = sinon.spy(this.player, 'src');
  currentTimeSpy = sinon.spy(this.player, 'currentTime');

  // with a separate video display or server-side ad insertion, ads play but
  // the src never changes. Modifying the src or currentTime would introduce
  // unnecessary seeking and rebuffering
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  assert.ok(playSpy.called, 'content playback resumed');
  assert.ok(srcSpy.alwaysCalledWithExactly(), 'the src was not reset');

  this.player.trigger('playing');

  // the src wasn't changed, so we shouldn't be waiting on loadedmetadata to
  // update the currentTime
  this.player.trigger('loadedmetadata');
  assert.ok(currentTimeSpy.alwaysCalledWithExactly(), 'no seeking occurred');
});

QUnit.test('snapshot does not resume playback after post-rolls', function (assert) {
  var playSpy = sinon.spy(this.player, 'play');

  // start playback
  this.player.src({
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');
  this.player.trigger('loadedmetadata');
  this.player.trigger('adsready');
  this.player.tech_.trigger('play');

  // trigger an ad
  this.player.ads.startLinearAdMode();
  this.player.src({
    src: '//example.com/ad.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');
  this.player.trigger('loadedmetadata');
  this.player.ads.endLinearAdMode();

  // resume playback
  this.player.src({
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');
  this.player.trigger('canplay');

  // "canplay" causes the `restorePlayerSnapshot` function in the plugin
  // to be called. This causes content playback to be resumed after 20
  // attempts of a 50ms timeout (20 * 50 == 1000).
  this.clock.tick(1000);
  assert.strictEqual(playSpy.callCount, 1, 'content playback resumed');

  this.player.trigger('playing');

  // if the video ends (regardless of burned in post-roll or otherwise) when
  // stopLinearAdMode fires next we should not hit play() since we have reached
  // the end of the stream
  this.player.ended = function () {
    return true;
  };

  this.player.trigger('ended');
  playSpy.reset();

  // trigger a post-roll
  this.player.ads.startLinearAdMode();
  this.player.src({
    src: '//example.com/ad.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');
  this.player.trigger('loadedmetadata');
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  this.player.trigger('ended');
  assert.strictEqual(playSpy.callCount, 0, 'content playback should not have been resumed');
});

QUnit.test('snapshot does not resume playback after a burned-in post-roll', function (assert) {
  var playSpy, loadSpy;

  this.player.trigger('adsready');
  this.player.trigger('play');
  playSpy = sinon.spy(this.player, 'play');
  loadSpy = sinon.spy(this.player, 'load');
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  assert.ok(playSpy.called, 'content playback resumed');

  // if the video ends (regardless of burned in post-roll or otherwise) when
  // stopLinearAdMode fires next we should not hit play() since we have reached
  // the end of the stream
  this.player.ended = function () {
    return true;
  };

  this.player.trigger('ended');
  playSpy.reset();

  // trigger a post-roll
  this.player.currentTime(30);
  this.player.ads.startLinearAdMode();
  this.player.currentTime(50);
  this.player.ads.endLinearAdMode();
  this.player.trigger('ended');
  assert.strictEqual(this.player.currentTime(), 50, 'currentTime should not be reset using burned in ads');
  assert.notOk(loadSpy.called, 'player.load() should not be called if the player is ended.');
  assert.notOk(playSpy.called, 'content playback should not have been resumed');
});

QUnit.test('snapshot does not resume playback after multiple post-rolls', function (assert) {
  var playSpy;

  this.player.src({
    src: 'http://vjs.zencdn.net/v/oceans.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  playSpy = sinon.spy(this.player, 'play');

  // with a separate video display or server-side ad insertion, ads play but
  // the src never changes. Modifying the src or currentTime would introduce
  // unnecessary seeking and rebuffering
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  assert.ok(playSpy.called, 'content playback resumed');

  // if the video ends (regardless of burned in post-roll or otherwise) when
  // stopLinearAdMode fires next we should not hit play() since we have reached
  // the end of the stream
  this.player.ended = function () {
    return true;
  };

  this.player.trigger('ended');
  playSpy.reset();

  // trigger a lot of post-rolls
  this.player.ads.startLinearAdMode();
  this.player.src({
    src: 'http://example.com/ad1.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');
  this.player.src({
    src: 'http://example.com/ad2.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  this.player.trigger('ended');
  assert.notOk(playSpy.called, 'content playback should not resume');
});

QUnit.test('changing the source and then timing out does not restore a snapshot', function (assert) {

  this.player.paused = function () {
    return false;
  };

  // load and play the initial video
  this.player.src({
    src: 'http://example.com/movie.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');
  this.player.trigger('play');
  this.player.trigger('adsready');

  // preroll
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');

  // change the content and timeout the new ad response
  this.player.src({
    src: 'http://example.com/movie2.webm',
    type: 'video/webm'
  });
  this.player.trigger('loadstart');
  this.player.trigger('adtimeout');
  assert.strictEqual('http://example.com/movie2.webm', this.player.currentSrc(), 'playing the second video');
});

// changing the src attribute to a URL that AdBlocker is intercepting
// doesn't update currentSrc, so when restoring the snapshot we
// should check for src attribute modifications as well
QUnit.test('checks for a src attribute change that isn\'t reflected in currentSrc', function (assert) {
  var updatedSrc;

  this.player.currentSource = function () {
    return { src: 'content.webm', type: 'video/webm' };
  };

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();

  // `src` gets called internally to set the source back to its original
  // value when the player snapshot is restored when `endLinearAdMode`
  // is called.
  this.player.tech_.src = function (source) {
    if (source === undefined) {
      return 'ad.webm';
    }
    updatedSrc = source;
  };

  this.player.src = function (source) {
    if (source === undefined) {
      return 'ad.webm';
    }
    updatedSrc = source;
  };

  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  assert.deepEqual(updatedSrc, [this.player.currentSource()], 'restored src attribute');
});

QUnit.test('When captions are enabled, the content\'s tracks will be disabled during the ad', function (assert) {
  var trackSrc = '/base/test/integration/lib/testcaption.vtt';
  var remoteTrack = void 0;

  // Add a text track
  remoteTrack = this.player.addRemoteTextTrack({
    kind: 'captions',
    language: 'fr',
    label: 'French',
    src: trackSrc
  });

  var tracks = this.player.textTracks ? this.player.textTracks() : [];
  var showing = 0;
  var disabled = 0;
  var i;

  if (tracks.length <= 0) {
    assert.expect(0);
    videojs$1.log.warn('Did not detect text track support, skipping');
    return;
  }

  assert.expect(3);
  this.player.trigger('adsready');
  this.player.trigger('play');

  // set all modes to 'showing'
  for (i = 0; i < tracks.length; i++) {
    tracks[i].mode = 'showing';
  }

  for (i = 0; i < tracks.length; i++) {
    if (tracks[i].mode === 'showing') {
      showing++;
    }
  }

  assert.strictEqual(showing, tracks.length, 'all tracks should be showing');
  showing = 0;
  this.player.ads.startLinearAdMode();

  for (i = 0; i < tracks.length; i++) {
    if (tracks[i].mode === 'disabled') {
      disabled++;
    }
  }

  assert.strictEqual(disabled, tracks.length, 'all tracks should be disabled');
  this.player.ads.endLinearAdMode();

  // Track mode should be restored after the ad ends
  for (i = 0; i < tracks.length; i++) {
    if (tracks[i].mode === 'showing') {
      showing++;
    }
  }

  assert.strictEqual(showing, tracks.length, 'all tracks should be showing');

  // Cleanup
  this.player.textTracks().removeTrack(remoteTrack);
});

QUnit.test('No snapshot if duration is Infinity', function (assert) {
  var originalSrc = 'foobar';
  var newSrc = 'barbaz';

  this.player.duration(Infinity);

  this.player.src({
    src: originalSrc,
    type: 'video/webm'
  });
  this.player.trigger('adsready');
  this.player.play();
  this.player.ads.startLinearAdMode();
  this.player.src({
    src: newSrc,
    type: 'video/webm'
  });
  this.player.ads.endLinearAdMode();
  assert.strictEqual(this.player.currentSrc(), newSrc, 'source is not reset');
});

QUnit.test('Snapshot and text tracks', function (assert) {
  var trackSrc = '/base/test/integration/lib/testcaption.vtt';
  var originalAddTrack = this.player.addTextTrack;
  var originalTextTracks = this.player.textTracks;
  var remoteTrack = void 0;

  // No text tracks at start
  assert.equal(this.player.textTracks().length, 0);

  this.player.addTextTrack('captions', 'Spanish', 'es');

  // Add a text track
  remoteTrack = this.player.addRemoteTextTrack({
    kind: 'captions',
    language: 'fr',
    label: 'French',
    src: trackSrc
  });

  // Make sure both track modes are 'showing', since it's 'disabled' by default
  this.player.textTracks()[0].mode = 'showing';
  this.player.textTracks()[1].mode = 'showing';

  // Text track looks good
  assert.equal(this.player.textTracks().length, 2);
  assert.equal(this.player.textTracks()[0].kind, 'captions');
  assert.equal(this.player.textTracks()[0].language, 'es');
  assert.equal(this.player.textTracks()[0].mode, 'showing');

  assert.equal(this.player.remoteTextTrackEls().trackElements_[0].src, trackSrc);
  assert.equal(this.player.textTracks()[1].kind, 'captions');
  assert.equal(this.player.textTracks()[1].language, 'fr');
  assert.equal(this.player.textTracks()[1].mode, 'showing');

  // Do a snapshot, as if an ad is starting
  this.player.ads.snapshot = getPlayerSnapshot(this.player);

  // Snapshot reflects the text track
  assert.equal(this.player.ads.snapshot.suppressedTracks.length, 2);
  assert.equal(this.player.ads.snapshot.suppressedTracks[0].track.kind, 'captions');
  assert.equal(this.player.ads.snapshot.suppressedTracks[0].track.language, 'es');
  assert.equal(this.player.ads.snapshot.suppressedTracks[0].mode, 'showing');

  assert.equal(this.player.ads.snapshot.suppressedTracks[1].track.kind, 'captions');
  assert.equal(this.player.ads.snapshot.suppressedTracks[1].track.language, 'fr');
  assert.equal(this.player.ads.snapshot.suppressedTracks[1].mode, 'showing');

  // Meanwhile, track is intact, just disabled
  assert.equal(this.player.textTracks().length, 2);
  assert.equal(this.player.textTracks()[0].kind, 'captions');
  assert.equal(this.player.textTracks()[0].language, 'es');
  assert.equal(this.player.textTracks()[0].mode, 'disabled');

  assert.equal(this.player.remoteTextTrackEls().trackElements_[0].src, trackSrc);
  assert.equal(this.player.textTracks()[1].kind, 'captions');
  assert.equal(this.player.textTracks()[1].language, 'fr');
  assert.equal(this.player.textTracks()[1].mode, 'disabled');

  // Double check that the track remains disabled after 3s
  this.clock.tick(3000);
  assert.equal(this.player.textTracks()[0].mode, 'disabled');
  assert.equal(this.player.textTracks()[1].mode, 'disabled');

  // Restore the snapshot, as if an ad is ending
  restorePlayerSnapshot(this.player);

  // Everything is back to normal
  assert.equal(this.player.textTracks().length, 2);
  assert.equal(this.player.textTracks()[0].kind, 'captions');
  assert.equal(this.player.textTracks()[0].language, 'es');
  assert.equal(this.player.textTracks()[0].mode, 'showing');

  assert.equal(this.player.remoteTextTrackEls().trackElements_[0].src, trackSrc);
  assert.equal(this.player.textTracks()[1].kind, 'captions');
  assert.equal(this.player.textTracks()[1].language, 'fr');
  assert.equal(this.player.textTracks()[1].mode, 'showing');

  // Resetting mocked methods
  this.player.textTracks().removeTrack(remoteTrack);
  this.player.addTextTrack = originalAddTrack;
  this.player.textTracks = originalTextTracks;
});

QUnit.test('Snapshot object is cleaned up', function (assert) {
  assert.equal(_typeof(this.player.ads.snapshot), 'undefined', 'no snapshot before ad');
  this.player.ads.snapshot = getPlayerSnapshot(this.player);
  assert.equal(_typeof(this.player.ads.snapshot), 'object', 'snapshot during ad');
  restorePlayerSnapshot(this.player);
  assert.equal(_typeof(this.player.ads.snapshot), 'undefined', 'no snapshot after ad');
});

QUnit.test('Call play after live preroll on iOS', function (assert) {
  var played = 0;

  this.player.duration(Infinity);
  this.player.ads.videoElementRecycled = function () {
    return true;
  };
  videojs$1.browser = { IS_IOS: true };
  this.player.play = function () {
    played++;
  };

  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');

  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  this.player.el().querySelector = function (query) {
    if (query === '.vjs-tech') {
      return { seekable: { length: 1 } };
    }
  };
  assert.strictEqual(played, 0, 'No play yet');
  this.player.trigger('contentcanplay');
  assert.strictEqual(played, 1, 'Play happened');
});

// This is an example of a very simple, naive stitched ads plugin. This means
// there is a single source within which are the "ads".
//
// We'll simulate a preroll for the first 5 seconds of playback, a midroll at
// 15 seconds, and a postroll.
//
// In reality, it's left up to the integration to define when and where ad
// mode is started and ended via some kind of mapping or manifest.
//
videojs.registerPlugin('exampleStitchedAds', function (options) {
  var player = this;

  options = options || {};
  options.stitchedAds = true;

  // Initialize contrib-ads.
  player.ads(options);

  player.on('canplay', function () {
    player.one('playing', function () {
      var havePlayedPreroll = false;
      var haveStartedMidroll = false;
      var haveStartedPostroll = false;
      var havePlayedMidroll = false;

      // Simulate a pre-roll immediately upon playback starting.
      player.ads.startLinearAdMode();

      // Simulate a mid-roll at 15 seconds and a post-roll at 5 seconds from
      // the end. Need to listen to both timeupdate and adtimeupdate because
      // redispatch will prefix during ads.
      player.on(['timeupdate', 'adtimeupdate'], function (e) {
        var currentTime = player.currentTime();
        var duration = player.duration();

        // End the pre-roll.
        if (!havePlayedPreroll && currentTime >= 5) {
          havePlayedPreroll = true;
          player.ads.endLinearAdMode();
          return;
        }

        // Start the mid-roll.
        if (!haveStartedMidroll && currentTime >= 15) {
          haveStartedMidroll = true;
          player.ads.startLinearAdMode();
          return;
        }

        // End the mid-roll.
        if (!havePlayedMidroll && currentTime >= 20) {
          havePlayedMidroll = true;
          player.ads.endLinearAdMode();
          return;
        }

        // Start the post-roll.
        // The post-roll will be ended automatically via the `adended` event.
        if (!haveStartedPostroll && currentTime >= duration - 5) {
          haveStartedPostroll = true;
          player.ads.startLinearAdMode();
          return;
        }
      });
    });
  });
});

/*
TODO:
* timeupdate, adtimeupdate, contenttimeupdate
* loadstart, adloadstart, contentloadstart
* play, adplay, contentplay
* loadeddata, adloadeddata, contentloadeddata
* loadedmetadata, adloadedmetadata, contentloadedmetadata
*/

var originalTestTimeout = QUnit.config.testTimeout;

QUnit.module('Events and Stitched Ads', {
  before: function before() {
    QUnit.config.testTimeout = 30000;
  },
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.querySelector('#qunit-fixture');
    this.fixture.appendChild(this.video);

    this.player = videojs$1(this.video);
    this.player.exampleStitchedAds();

    this.player.src({
      src: 'http://vjs.zencdn.net/v/oceans.webm',
      type: 'video/webm'
    });
  },
  afterEach: function afterEach() {
    this.player.dispose();
  },
  after: function after() {
    QUnit.config.testTimeout = originalTestTimeout;
  }
});

QUnit.test('Stitched Ads', function (assert) {
  var done = assert.async();

  var seenBeforePreroll = [];
  var seenDuringPreroll = [];
  var seenAfterPreroll = [];
  var seenDuringMidroll = [];
  var seenAfterMidroll = [];
  var currentEventLog = seenBeforePreroll;

  var events = ['suspend', 'abort', 'error', 'emptied', 'stalled', 'canplay', 'canplaythrough', 'waiting', 'seeking', 'durationchange', 'progress', 'pause', 'ratechange', 'volumechange', 'firstplay', 'suspend', 'playing', 'ended'];

  events = events.concat(events.map(function (e) {
    return 'ad' + e;
  })).concat(events.map(function (e) {
    return 'content' + e;
  }));

  var player = this.player;


  player.on('adstart', function () {
    if (currentEventLog === seenBeforePreroll) {
      currentEventLog = seenDuringPreroll;
    } else {
      currentEventLog = seenDuringMidroll;
    }
  });

  player.on('adend', function () {
    if (currentEventLog === seenDuringPreroll) {
      currentEventLog = seenAfterPreroll;
    } else {
      currentEventLog = seenAfterMidroll;
    }
  });

  player.on(events, function (e) {
    return currentEventLog.push(e.type);
  });

  player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  player.on('timeupdate', function () {
    videojs$1.log(player.currentTime(), player.currentSrc());

    if (player.currentTime() > 21) {
      seenBeforePreroll.forEach(function (event) {
        assert.ok(!/^ad/.test(event), event + ' has no ad prefix before preroll');
        assert.ok(!/^content/.test(event), event + ' has no content prefix before preroll');
      });

      seenDuringPreroll.forEach(function (event) {
        assert.ok(/^ad/.test(event), event + ' has ad prefix during preroll');
      });

      seenAfterPreroll.forEach(function (event) {
        assert.ok(!/^ad/.test(event), event + ' has no ad prefix after preroll');
        assert.ok(!/^content/.test(event), event + ' has no content prefix after preroll');
      });

      seenDuringMidroll.forEach(function (event) {
        assert.ok(/^ad/.test(event), event + ' has ad prefix during midroll');
      });

      seenAfterMidroll.forEach(function (event) {
        assert.ok(!/^ad/.test(event), event + ' has no ad prefix after midroll');
        assert.ok(!/^content/.test(event), event + ' has no content prefix after midroll');
      });

      done();
    }
  });

  player.ready(player.play);
});

var State = function () {
  State._getName = function _getName() {
    return 'Anonymous State';
  };

  function State(player) {
    classCallCheck(this, State);

    this.player = player;
  }

  /*
   * This is the only allowed way to perform state transitions. State transitions usually
   * happen in player event handlers. They can also happen recursively in `init`. They
   * should _not_ happen in `cleanup`.
   */


  State.prototype.transitionTo = function transitionTo(NewState) {
    var player = this.player;
    var previousState = this;

    previousState.cleanup(player);
    var newState = new NewState(player);

    player.ads._state = newState;
    player.ads.debug(previousState.constructor._getName() + ' -> ' + newState.constructor._getName());

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    newState.init.apply(newState, [player].concat(args));
  };

  /*
   * Implemented by subclasses to provide initialization logic when transitioning
   * to a new state.
   */


  State.prototype.init = function init() {};

  /*
   * Implemented by subclasses to provide cleanup logic when transitioning
   * to a new state.
   */


  State.prototype.cleanup = function cleanup() {};

  /*
   * Default event handlers. Different states can override these to provide behaviors.
   */


  State.prototype.onPlay = function onPlay() {};

  State.prototype.onPlaying = function onPlaying() {};

  State.prototype.onEnded = function onEnded() {};

  State.prototype.onAdEnded = function onAdEnded() {};

  State.prototype.onAdsReady = function onAdsReady() {
    videojs$1.log.warn('Unexpected adsready event');
  };

  State.prototype.onAdsError = function onAdsError() {};

  State.prototype.onAdsCanceled = function onAdsCanceled() {};

  State.prototype.onAdTimeout = function onAdTimeout() {};

  State.prototype.onAdStarted = function onAdStarted() {};

  State.prototype.onContentChanged = function onContentChanged() {};

  State.prototype.onContentResumed = function onContentResumed() {};

  State.prototype.onReadyForPostroll = function onReadyForPostroll() {
    videojs$1.log.warn('Unexpected readyforpostroll event');
  };

  State.prototype.onNoPreroll = function onNoPreroll() {};

  State.prototype.onNoPostroll = function onNoPostroll() {};

  /*
   * Method handlers. Different states can override these to provide behaviors.
   */


  State.prototype.startLinearAdMode = function startLinearAdMode() {
    videojs$1.log.warn('Unexpected startLinearAdMode invocation ' + '(State via ' + this.constructor._getName() + ')');
  };

  State.prototype.endLinearAdMode = function endLinearAdMode() {
    videojs$1.log.warn('Unexpected endLinearAdMode invocation ' + '(State via ' + this.constructor._getName() + ')');
  };

  State.prototype.skipLinearAdMode = function skipLinearAdMode() {
    videojs$1.log.warn('Unexpected skipLinearAdMode invocation ' + '(State via ' + this.constructor._getName() + ')');
  };

  /*
   * Overridden by ContentState and AdState. Should not be overriden elsewhere.
   */


  State.prototype.isAdState = function isAdState() {
    throw new Error('isAdState unimplemented for ' + this.constructor._getName());
  };

  /*
   * Overridden by Preroll and Postroll. Midrolls jump right into the ad break
   * so there is no "waiting" state for them.
   */


  State.prototype.isWaitingForAdBreak = function isWaitingForAdBreak() {
    return false;
  };

  /*
   * Overridden by Preroll, Midroll, and Postroll.
   */


  State.prototype.isContentResuming = function isContentResuming() {
    return false;
  };

  State.prototype.inAdBreak = function inAdBreak() {
    return false;
  };

  /*
   * Invoke event handler methods when events come in.
   */


  State.prototype.handleEvent = function handleEvent(type) {
    var player = this.player;

    if (type === 'play') {
      this.onPlay(player);
    } else if (type === 'adsready') {
      this.onAdsReady(player);
    } else if (type === 'adserror') {
      this.onAdsError(player);
    } else if (type === 'adscanceled') {
      this.onAdsCanceled(player);
    } else if (type === 'adtimeout') {
      this.onAdTimeout(player);
    } else if (type === 'ads-ad-started') {
      this.onAdStarted(player);
    } else if (type === 'contentchanged') {
      this.onContentChanged(player);
    } else if (type === 'contentresumed') {
      this.onContentResumed(player);
    } else if (type === 'readyforpostroll') {
      this.onReadyForPostroll(player);
    } else if (type === 'playing') {
      this.onPlaying(player);
    } else if (type === 'ended') {
      this.onEnded(player);
    } else if (type === 'nopreroll') {
      this.onNoPreroll(player);
    } else if (type === 'nopostroll') {
      this.onNoPostroll(player);
    } else if (type === 'adended') {
      this.onAdEnded(player);
    }
  };

  return State;
}();

/*
 * This class contains logic for all ads, be they prerolls, midrolls, or postrolls.
 * Primarily, this involves handling startLinearAdMode and endLinearAdMode.
 * It also handles content resuming.
 */

var AdState = function (_State) {
  inherits(AdState, _State);

  function AdState(player) {
    classCallCheck(this, AdState);

    var _this = possibleConstructorReturn(this, _State.call(this, player));

    _this.contentResuming = false;
    _this.waitingForAdBreak = false;
    return _this;
  }

  /*
   * Overrides State.isAdState
   */


  AdState.prototype.isAdState = function isAdState() {
    return true;
  };

  /*
   * We end the content-resuming process on the playing event because this is the exact
   * moment that content playback is no longer blocked by ads.
   */


  AdState.prototype.onPlaying = function onPlaying() {
    if (this.contentResuming) {
      this.transitionTo(ContentPlayback);
    }
  };

  /*
   * If the ad plugin does not result in a playing event when resuming content after an
   * ad, they should instead trigger a contentresumed event to signal that content should
   * resume. The main use case for this is when ads are stitched into the content video.
   */


  AdState.prototype.onContentResumed = function onContentResumed() {
    if (this.contentResuming) {
      this.transitionTo(ContentPlayback);
    }
  };

  /*
   * Check if we are in an ad state waiting for the ad plugin to start
   * an ad break.
   */


  AdState.prototype.isWaitingForAdBreak = function isWaitingForAdBreak() {
    return this.waitingForAdBreak;
  };

  /*
   * Allows you to check if content is currently resuming after an ad break.
   */


  AdState.prototype.isContentResuming = function isContentResuming() {
    return this.contentResuming;
  };

  /*
   * Allows you to check if an ad break is in progress.
   */


  AdState.prototype.inAdBreak = function inAdBreak() {
    return this.player.ads._inLinearAdMode === true;
  };

  return AdState;
}(State);

var ContentState = function (_State) {
  inherits(ContentState, _State);

  function ContentState() {
    classCallCheck(this, ContentState);
    return possibleConstructorReturn(this, _State.apply(this, arguments));
  }

  /*
   * Overrides State.isAdState
   */
  ContentState.prototype.isAdState = function isAdState() {
    return false;
  };

  /*
   * Source change sends you back to preroll checks. contentchanged does not
   * fire during ad breaks, so we don't need to worry about that.
   */


  ContentState.prototype.onContentChanged = function onContentChanged(player) {
    player.ads.debug('Received contentchanged event (ContentState)');
    if (player.paused()) {
      this.transitionTo(BeforePreroll);
    } else {
      this.transitionTo(Preroll, false);
      player.pause();
      player.ads._pausedOnContentupdate = true;
    }
  };

  return ContentState;
}(State);

/*
 * Encapsulates logic for starting and ending ad breaks. An ad break
 * is the time between startLinearAdMode and endLinearAdMode. The ad
 * plugin may play 0 or more ads during this time.
 */

function start(player) {
  player.ads.debug('Starting ad break');

  player.ads._inLinearAdMode = true;

  // No longer does anything, used to move us to ad-playback
  player.trigger('adstart');

  // Capture current player state snapshot
  if (player.ads.shouldTakeSnapshots()) {
    player.ads.snapshot = getPlayerSnapshot(player);
  }

  // Mute the player behind the ad
  if (player.ads.shouldPlayContentBehindAd(player)) {
    player.ads.preAdVolume_ = player.volume();
    player.volume(0);
  }

  // Add css to the element to indicate and ad is playing.
  player.addClass('vjs-ad-playing');

  // We should remove the vjs-live class if it has been added in order to
  // show the adprogress control bar on Android devices for falsely
  // determined LIVE videos due to the duration incorrectly reported as Infinity
  if (player.hasClass('vjs-live')) {
    player.removeClass('vjs-live');
  }

  // This removes the native poster so the ads don't show the content
  // poster if content element is reused for ad playback.
  player.ads.removeNativePoster();
}

function end(player, callback) {
  player.ads.debug('Ending ad break');

  if (callback === undefined) {
    callback = function callback() {};
  }

  player.ads.adType = null;

  player.ads._inLinearAdMode = false;

  // Signals the end of the ad break to anyone listening.
  player.trigger('adend');

  player.removeClass('vjs-ad-playing');

  // We should add the vjs-live class back if the video is a LIVE video
  // If we dont do this, then for a LIVE Video, we will get an incorrect
  // styled control, which displays the time for the video
  if (player.ads.isLive(player)) {
    player.addClass('vjs-live');
  }

  // Restore snapshot
  if (player.ads.shouldTakeSnapshots()) {
    restorePlayerSnapshot(player, callback);

    // Reset the volume to pre-ad levels
  } else {
    player.volume(player.ads.preAdVolume_);
    callback();
  }
}

var obj = { start: start, end: end };

/*
 * This state encapsulates waiting for prerolls, preroll playback, and
 * content restoration after a preroll.
 */

var Preroll = function (_AdState) {
  inherits(Preroll, _AdState);

  function Preroll() {
    classCallCheck(this, Preroll);
    return possibleConstructorReturn(this, _AdState.apply(this, arguments));
  }

  /*
   * Allows state name to be logged even after minification.
   */
  Preroll._getName = function _getName() {
    return 'Preroll';
  };

  /*
   * For state transitions to work correctly, initialization should
   * happen here, not in a constructor.
   */


  Preroll.prototype.init = function init(player, adsReady, shouldResumeToContent) {
    this.waitingForAdBreak = true;

    // Loading spinner from now until ad start or end of ad break.
    player.addClass('vjs-ad-loading');

    // If adserror, adscanceled, nopreroll or skipLinearAdMode already
    // ocurred, resume to content immediately
    if (shouldResumeToContent || player.ads.nopreroll_) {
      return this.resumeAfterNoPreroll(player);
    }

    // Determine preroll timeout based on plugin settings
    var timeout = player.ads.settings.timeout;

    if (typeof player.ads.settings.prerollTimeout === 'number') {
      timeout = player.ads.settings.prerollTimeout;
    }

    // Start the clock ticking for ad timeout
    this._timeout = player.setTimeout(function () {
      player.trigger('adtimeout');
    }, timeout);

    // If adsready already happened, lets get started. Otherwise,
    // wait until onAdsReady.
    if (adsReady) {
      this.handleAdsReady();
    } else {
      this.adsReady = false;
    }
  };

  /*
   * Adsready event after play event.
   */


  Preroll.prototype.onAdsReady = function onAdsReady(player) {
    if (!player.ads.inAdBreak()) {
      player.ads.debug('Received adsready event (Preroll)');
      this.handleAdsReady();
    } else {
      videojs$1.log.warn('Unexpected adsready event (Preroll)');
    }
  };

  /*
   * Ad plugin is ready. Let's get started on this preroll.
   */


  Preroll.prototype.handleAdsReady = function handleAdsReady() {
    this.adsReady = true;
    this.readyForPreroll();
  };

  /*
   * Helper to call a callback only after a loadstart event.
   * If we start content or ads before loadstart, loadstart
   * will not be prefixed correctly.
   */


  Preroll.prototype.afterLoadStart = function afterLoadStart(callback) {
    var player = this.player;

    if (player.ads._hasThereBeenALoadStartDuringPlayerLife) {
      callback();
    } else {
      player.ads.debug('Waiting for loadstart...');
      player.one('loadstart', function () {
        player.ads.debug('Received loadstart event');
        callback();
      });
    }
  };

  /*
   * If there is no preroll, play content instead.
   */


  Preroll.prototype.noPreroll = function noPreroll() {
    var _this2 = this;

    this.afterLoadStart(function () {
      _this2.player.ads.debug('Skipping prerolls due to nopreroll event (Preroll)');
      _this2.resumeAfterNoPreroll(_this2.player);
    });
  };

  /*
   * Fire the readyforpreroll event. If loadstart hasn't happened yet,
   * wait until loadstart first.
   */


  Preroll.prototype.readyForPreroll = function readyForPreroll() {
    var player = this.player;

    this.afterLoadStart(function () {
      player.ads.debug('Triggered readyforpreroll event (Preroll)');
      player.trigger('readyforpreroll');
    });
  };

  /*
   * adscanceled cancels all ads for the source. Play content now.
   */


  Preroll.prototype.onAdsCanceled = function onAdsCanceled(player) {
    var _this3 = this;

    player.ads.debug('adscanceled (Preroll)');

    this.afterLoadStart(function () {
      _this3.resumeAfterNoPreroll(player);
    });
  };

  /*
   * An ad error occured. Play content instead.
   */


  Preroll.prototype.onAdsError = function onAdsError(player) {
    var _this4 = this;

    videojs$1.log('adserror (Preroll)');
    // In the future, we may not want to do this automatically.
    // Ad plugins should be able to choose to continue the ad break
    // if there was an error.
    if (this.inAdBreak()) {
      player.ads.endLinearAdMode();
    } else {
      this.afterLoadStart(function () {
        _this4.resumeAfterNoPreroll(player);
      });
    }
  };

  /*
   * Ad plugin invoked startLinearAdMode, the ad break starts now.
   */


  Preroll.prototype.startLinearAdMode = function startLinearAdMode() {
    var player = this.player;

    if (this.adsReady && !player.ads.inAdBreak() && !this.isContentResuming()) {
      player.clearTimeout(this._timeout);
      player.ads.adType = 'preroll';
      this.waitingForAdBreak = false;
      obj.start(player);

      // We don't need to block play calls anymore
      player.ads._shouldBlockPlay = false;
    } else {
      videojs$1.log.warn('Unexpected startLinearAdMode invocation (Preroll)');
    }
  };

  /*
   * An ad has actually started playing.
   * Remove the loading spinner.
   */


  Preroll.prototype.onAdStarted = function onAdStarted(player) {
    player.removeClass('vjs-ad-loading');
  };

  /*
   * Ad plugin invoked endLinearAdMode, the ad break ends now.
   */


  Preroll.prototype.endLinearAdMode = function endLinearAdMode() {
    var player = this.player;

    if (this.inAdBreak()) {
      player.removeClass('vjs-ad-loading');
      player.addClass('vjs-ad-content-resuming');
      this.contentResuming = true;
      obj.end(player);
    }
  };

  /*
   * Ad skipped by ad plugin. Play content instead.
   */


  Preroll.prototype.skipLinearAdMode = function skipLinearAdMode() {
    var _this5 = this;

    var player = this.player;

    if (player.ads.inAdBreak() || this.isContentResuming()) {
      videojs$1.log.warn('Unexpected skipLinearAdMode invocation');
    } else {
      this.afterLoadStart(function () {
        player.trigger('adskip');
        player.ads.debug('skipLinearAdMode (Preroll)');
        _this5.resumeAfterNoPreroll(player);
      });
    }
  };

  /*
   * Prerolls took too long! Play content instead.
   */


  Preroll.prototype.onAdTimeout = function onAdTimeout(player) {
    var _this6 = this;

    this.afterLoadStart(function () {
      player.ads.debug('adtimeout (Preroll)');
      _this6.resumeAfterNoPreroll(player);
    });
  };

  /*
   * Check if nopreroll event was too late before handling it.
   */


  Preroll.prototype.onNoPreroll = function onNoPreroll(player) {
    if (player.ads.inAdBreak() || this.isContentResuming()) {
      videojs$1.log.warn('Unexpected nopreroll event (Preroll)');
    } else {
      this.noPreroll();
    }
  };

  Preroll.prototype.resumeAfterNoPreroll = function resumeAfterNoPreroll(player) {
    // Resume to content and unblock play as there is no preroll ad
    this.contentResuming = true;
    player.ads._shouldBlockPlay = false;

    // Play the content if we had requested play or we paused on 'contentupdate'
    // and we haven't played yet. This happens if there was no preroll or if it
    // errored, timed out, etc. Otherwise snapshot restore would play.
    if (player.paused() && (player.ads._playRequested || player.ads._pausedOnContentupdate)) {
      player.play();
    }
  };

  /*
   * Cleanup timeouts and spinner.
   */


  Preroll.prototype.cleanup = function cleanup(player) {
    if (!player.ads._hasThereBeenALoadStartDuringPlayerLife) {
      videojs$1.log.warn('Leaving Preroll state before loadstart event can cause issues.');
    }

    player.removeClass('vjs-ad-loading');
    player.removeClass('vjs-ad-content-resuming');
    player.clearTimeout(this._timeout);
  };

  return Preroll;
}(AdState);

var Midroll = function (_AdState) {
  inherits(Midroll, _AdState);

  function Midroll() {
    classCallCheck(this, Midroll);
    return possibleConstructorReturn(this, _AdState.apply(this, arguments));
  }

  /*
   * Allows state name to be logged even after minification.
   */
  Midroll._getName = function _getName() {
    return 'Midroll';
  };

  /*
   * Midroll breaks happen when the ad plugin calls startLinearAdMode,
   * which can happen at any time during content playback.
   */


  Midroll.prototype.init = function init(player) {
    player.ads.adType = 'midroll';
    obj.start(player);
    player.addClass('vjs-ad-loading');
  };

  /*
   * An ad has actually started playing.
   * Remove the loading spinner.
   */


  Midroll.prototype.onAdStarted = function onAdStarted(player) {
    player.removeClass('vjs-ad-loading');
  };

  /*
   * Midroll break is done.
   */


  Midroll.prototype.endLinearAdMode = function endLinearAdMode() {
    var player = this.player;

    if (this.inAdBreak()) {
      this.contentResuming = true;
      player.addClass('vjs-ad-content-resuming');
      player.removeClass('vjs-ad-loading');
      obj.end(player);
    }
  };

  /*
   * End midroll break if there is an error.
   */


  Midroll.prototype.onAdsError = function onAdsError(player) {
    // In the future, we may not want to do this automatically.
    // Ad plugins should be able to choose to continue the ad break
    // if there was an error.
    if (this.inAdBreak()) {
      player.ads.endLinearAdMode();
    }
  };

  /*
   * Cleanup CSS classes.
   */


  Midroll.prototype.cleanup = function cleanup(player) {
    player.removeClass('vjs-ad-loading');
    player.removeClass('vjs-ad-content-resuming');
  };

  return Midroll;
}(AdState);

var Postroll = function (_AdState) {
  inherits(Postroll, _AdState);

  function Postroll() {
    classCallCheck(this, Postroll);
    return possibleConstructorReturn(this, _AdState.apply(this, arguments));
  }

  /*
   * Allows state name to be logged even after minification.
   */
  Postroll._getName = function _getName() {
    return 'Postroll';
  };

  /*
   * For state transitions to work correctly, initialization should
   * happen here, not in a constructor.
   */


  Postroll.prototype.init = function init(player) {
    this.waitingForAdBreak = true;

    // Legacy name that now simply means "handling postrolls".
    player.ads._contentEnding = true;

    // Start postroll process.
    if (!player.ads.nopostroll_) {
      player.addClass('vjs-ad-loading');

      // Determine postroll timeout based on plugin settings
      var timeout = player.ads.settings.timeout;

      if (typeof player.ads.settings.postrollTimeout === 'number') {
        timeout = player.ads.settings.postrollTimeout;
      }

      this._postrollTimeout = player.setTimeout(function () {
        player.trigger('adtimeout');
      }, timeout);

      // No postroll, ads are done
    } else {
      this.resumeContent(player);
      this.transitionTo(AdsDone);
    }
  };

  /*
   * Start the postroll if it's not too late.
   */


  Postroll.prototype.startLinearAdMode = function startLinearAdMode() {
    var player = this.player;

    if (!player.ads.inAdBreak() && !this.isContentResuming()) {
      player.ads.adType = 'postroll';
      player.clearTimeout(this._postrollTimeout);
      this.waitingForAdBreak = false;
      obj.start(player);
    } else {
      videojs$1.log.warn('Unexpected startLinearAdMode invocation (Postroll)');
    }
  };

  /*
   * An ad has actually started playing.
   * Remove the loading spinner.
   */


  Postroll.prototype.onAdStarted = function onAdStarted(player) {
    player.removeClass('vjs-ad-loading');
  };

  /*
   * Ending a postroll triggers the ended event.
   */


  Postroll.prototype.endLinearAdMode = function endLinearAdMode() {
    var _this2 = this;

    var player = this.player;

    if (this.inAdBreak()) {
      player.removeClass('vjs-ad-loading');
      this.resumeContent(player);
      obj.end(player, function () {
        _this2.transitionTo(AdsDone);
      });
    }
  };

  /*
   * Postroll skipped, time to clean up.
   */


  Postroll.prototype.skipLinearAdMode = function skipLinearAdMode() {
    var player = this.player;

    if (player.ads.inAdBreak() || this.isContentResuming()) {
      videojs$1.log.warn('Unexpected skipLinearAdMode invocation');
    } else {
      player.ads.debug('Postroll abort (skipLinearAdMode)');
      player.trigger('adskip');
      this.abort(player);
    }
  };

  /*
   * Postroll timed out, time to clean up.
   */


  Postroll.prototype.onAdTimeout = function onAdTimeout(player) {
    player.ads.debug('Postroll abort (adtimeout)');
    this.abort(player);
  };

  /*
   * Postroll errored out, time to clean up.
   */


  Postroll.prototype.onAdsError = function onAdsError(player) {
    player.ads.debug('Postroll abort (adserror)');

    // In the future, we may not want to do this automatically.
    // Ad plugins should be able to choose to continue the ad break
    // if there was an error.
    if (player.ads.inAdBreak()) {
      player.ads.endLinearAdMode();
    } else {
      this.abort(player);
    }
  };

  /*
   * Handle content change if we're not in an ad break.
   */


  Postroll.prototype.onContentChanged = function onContentChanged(player) {
    // Content resuming after Postroll. Content is paused
    // at this point, since it is done playing.
    if (this.isContentResuming()) {
      this.transitionTo(BeforePreroll);

      // Waiting for postroll to start. Content is considered playing
      // at this point, since it had to be playing to start the postroll.
    } else if (!this.inAdBreak()) {
      this.transitionTo(Preroll);
    }
  };

  /*
   * Wrap up if there is no postroll.
   */


  Postroll.prototype.onNoPostroll = function onNoPostroll(player) {
    if (!this.isContentResuming() && !this.inAdBreak()) {
      this.abort(player);
    } else {
      videojs$1.log.warn('Unexpected nopostroll event (Postroll)');
    }
  };

  Postroll.prototype.resumeContent = function resumeContent(player) {
    this.contentResuming = true;
    player.addClass('vjs-ad-content-resuming');
  };

  /*
   * Helper for ending Postrolls. In the future we may want to
   * refactor this class so that `cleanup` handles all of this.
   */


  Postroll.prototype.abort = function abort(player) {
    this.resumeContent(player);
    player.removeClass('vjs-ad-loading');
    this.transitionTo(AdsDone);
  };

  /*
   * Cleanup timeouts and state.
   */


  Postroll.prototype.cleanup = function cleanup(player) {
    player.removeClass('vjs-ad-content-resuming');
    player.clearTimeout(this._postrollTimeout);
    player.ads._contentEnding = false;
  };

  return Postroll;
}(AdState);

/*
 * This is the initial state for a player with an ad plugin. Normally, it remains in this
 * state until a "play" event is seen. After that, we enter the Preroll state to check for
 * prerolls. This happens regardless of whether or not any prerolls ultimately will play.
 * Errors and other conditions may lead us directly from here to ContentPlayback.
 */

var BeforePreroll = function (_ContentState) {
  inherits(BeforePreroll, _ContentState);

  function BeforePreroll() {
    classCallCheck(this, BeforePreroll);
    return possibleConstructorReturn(this, _ContentState.apply(this, arguments));
  }

  /*
   * Allows state name to be logged even after minification.
   */
  BeforePreroll._getName = function _getName() {
    return 'BeforePreroll';
  };

  /*
   * For state transitions to work correctly, initialization should
   * happen here, not in a constructor.
   */


  BeforePreroll.prototype.init = function init(player) {
    this.adsReady = false;
    this.shouldResumeToContent = false;

    // Content playback should be blocked until we are done
    // playing ads or we know there are no ads to play
    player.ads._shouldBlockPlay = true;
  };

  /*
   * The ad plugin may trigger adsready before the play request. If so,
   * we record that adsready already happened so the Preroll state will know.
   */


  BeforePreroll.prototype.onAdsReady = function onAdsReady(player) {
    player.ads.debug('Received adsready event (BeforePreroll)');
    this.adsReady = true;
  };

  /*
   * Ad mode officially begins on the play request, because at this point
   * content playback is blocked by the ad plugin.
   */


  BeforePreroll.prototype.onPlay = function onPlay(player) {
    player.ads.debug('Received play event (BeforePreroll)');

    // Check for prerolls
    this.transitionTo(Preroll, this.adsReady, this.shouldResumeToContent);
  };

  /*
   * All ads for the entire video are canceled.
   */


  BeforePreroll.prototype.onAdsCanceled = function onAdsCanceled(player) {
    player.ads.debug('adscanceled (BeforePreroll)');
    this.shouldResumeToContent = true;
  };

  /*
   * An ad error occured. Play content instead.
   */


  BeforePreroll.prototype.onAdsError = function onAdsError() {
    this.player.ads.debug('adserror (BeforePreroll)');
    this.shouldResumeToContent = true;
  };

  /*
   * If there is no preroll, don't wait for a play event to move forward.
   */


  BeforePreroll.prototype.onNoPreroll = function onNoPreroll() {
    this.player.ads.debug('Skipping prerolls due to nopreroll event (BeforePreroll)');
    this.shouldResumeToContent = true;
  };

  /*
   * Prerolls skipped by ad plugin. Play content instead.
   */


  BeforePreroll.prototype.skipLinearAdMode = function skipLinearAdMode() {
    var player = this.player;

    player.trigger('adskip');
    player.ads.debug('skipLinearAdMode (BeforePreroll)');
    this.shouldResumeToContent = true;
  };

  BeforePreroll.prototype.onContentChanged = function onContentChanged() {
    this.init(this.player);
  };

  return BeforePreroll;
}(ContentState);

/*
 * This state represents content playback the first time through before
 * content ends. After content has ended once, we check for postrolls and
 * move on to the AdsDone state rather than returning here.
 */

var ContentPlayback = function (_ContentState) {
  inherits(ContentPlayback, _ContentState);

  function ContentPlayback() {
    classCallCheck(this, ContentPlayback);
    return possibleConstructorReturn(this, _ContentState.apply(this, arguments));
  }

  /*
   * Allows state name to be logged even after minification.
   */
  ContentPlayback._getName = function _getName() {
    return 'ContentPlayback';
  };

  /*
   * For state transitions to work correctly, initialization should
   * happen here, not in a constructor.
   */


  ContentPlayback.prototype.init = function init(player) {
    // Don't block calls to play in content playback
    player.ads._shouldBlockPlay = false;
  };

  /*
   * In the case of a timeout, adsready might come in late. This assumes the behavior
   * that if an ad times out, it could still interrupt the content and start playing.
   * An ad plugin could behave otherwise by ignoring this event.
   */


  ContentPlayback.prototype.onAdsReady = function onAdsReady(player) {
    player.ads.debug('Received adsready event (ContentPlayback)');

    if (!player.ads.nopreroll_) {
      player.ads.debug('Triggered readyforpreroll event (ContentPlayback)');
      player.trigger('readyforpreroll');
    }
  };

  /*
   * Content ended before postroll checks.
   */


  ContentPlayback.prototype.onReadyForPostroll = function onReadyForPostroll(player) {
    player.ads.debug('Received readyforpostroll event');
    this.transitionTo(Postroll);
  };

  /*
   * This is how midrolls start.
   */


  ContentPlayback.prototype.startLinearAdMode = function startLinearAdMode() {
    this.transitionTo(Midroll);
  };

  return ContentPlayback;
}(ContentState);

var AdsDone = function (_ContentState) {
  inherits(AdsDone, _ContentState);

  function AdsDone() {
    classCallCheck(this, AdsDone);
    return possibleConstructorReturn(this, _ContentState.apply(this, arguments));
  }

  /*
   * Allows state name to be logged even after minification.
   */
  AdsDone._getName = function _getName() {
    return 'AdsDone';
  };

  /*
   * For state transitions to work correctly, initialization should
   * happen here, not in a constructor.
   */


  AdsDone.prototype.init = function init(player) {
    // From now on, `ended` events won't be redispatched
    player.ads._contentHasEnded = true;
    player.trigger('ended');
  };

  /*
   * Midrolls do not play after ads are done.
   */


  AdsDone.prototype.startLinearAdMode = function startLinearAdMode() {
    videojs$1.log.warn('Unexpected startLinearAdMode invocation (AdsDone)');
  };

  return AdsDone;
}(ContentState);

var StitchedAdRoll = function (_AdState) {
  inherits(StitchedAdRoll, _AdState);

  function StitchedAdRoll() {
    classCallCheck(this, StitchedAdRoll);
    return possibleConstructorReturn(this, _AdState.apply(this, arguments));
  }

  /*
   * Allows state name to be logged even after minification.
   */
  StitchedAdRoll._getName = function _getName() {
    return 'StitchedAdRoll';
  };

  /*
   * StitchedAdRoll breaks happen when the ad plugin calls startLinearAdMode,
   * which can happen at any time during content playback.
   */


  StitchedAdRoll.prototype.init = function init() {
    this.waitingForAdBreak = false;
    this.contentResuming = false;
    this.player.ads.adType = 'stitched';
    obj.start(this.player);
  };

  /*
   * For stitched ads, there is no "content resuming" scenario, so a "playing"
   * event is not relevant.
   */


  StitchedAdRoll.prototype.onPlaying = function onPlaying() {};

  /*
   * For stitched ads, there is no "content resuming" scenario, so a
   * "contentresumed" event is not relevant.
   */


  StitchedAdRoll.prototype.onContentResumed = function onContentResumed() {};

  /*
   * When we see an "adended" event, it means that we are in a postroll that
   * has ended (because the media ended and we are still in an ad state).
   *
   * In these cases, we transition back to content mode and fire ended.
   */


  StitchedAdRoll.prototype.onAdEnded = function onAdEnded() {
    this.endLinearAdMode();
    this.player.trigger('ended');
  };

  /*
   * StitchedAdRoll break is done.
   */


  StitchedAdRoll.prototype.endLinearAdMode = function endLinearAdMode() {
    obj.end(this.player);
    this.transitionTo(StitchedContentPlayback);
  };

  return StitchedAdRoll;
}(AdState);

/*
 * This state represents content playback when stitched ads are in play.
 */

var StitchedContentPlayback = function (_ContentState) {
  inherits(StitchedContentPlayback, _ContentState);

  function StitchedContentPlayback() {
    classCallCheck(this, StitchedContentPlayback);
    return possibleConstructorReturn(this, _ContentState.apply(this, arguments));
  }

  /*
   * Allows state name to be logged even after minification.
   */
  StitchedContentPlayback._getName = function _getName() {
    return 'StitchedContentPlayback';
  };

  /*
   * For state transitions to work correctly, initialization should
   * happen here, not in a constructor.
   */


  StitchedContentPlayback.prototype.init = function init() {

    // Don't block calls to play in stitched ad players, ever.
    this.player.ads._shouldBlockPlay = false;
  };

  /*
   * Source change does not do anything for stitched ad players.
   * contentchanged does not fire during ad breaks, so we don't need to
   * worry about that.
   */


  StitchedContentPlayback.prototype.onContentChanged = function onContentChanged() {
    this.player.ads.debug('Received contentchanged event (' + this._getName() + ')');
  };

  /*
   * This is how stitched ads start.
   */


  StitchedContentPlayback.prototype.startLinearAdMode = function startLinearAdMode() {
    this.transitionTo(StitchedAdRoll);
  };

  return StitchedContentPlayback;
}(ContentState);

/*
 * This file is necessary to avoid this rollup issue:
 * https://github.com/rollup/rollup/issues/1089
 */

/*
 * These tests are intended to be isolated unit tests for one state with all
 * other modules mocked.
 */
QUnit.module('AdState', {
  beforeEach: function beforeEach() {
    var _this = this;

    this.player = {
      ads: {}
    };

    this.adState = new AdState(this.player);
    this.adState.transitionTo = function (newState) {
      _this.newState = newState.name;
    };
  }
});

QUnit.test('does not start out with content resuming', function (assert) {
  assert.equal(this.adState.contentResuming, false);
});

QUnit.test('is an ad state', function (assert) {
  assert.equal(this.adState.isAdState(), true);
});

QUnit.test('transitions to ContentPlayback on playing if content resuming', function (assert) {
  this.adState.contentResuming = true;
  this.adState.onPlaying();
  assert.equal(this.newState, 'ContentPlayback');
});

QUnit.test('doesn\'t transition on playing if content not resuming', function (assert) {
  this.adState.onPlaying();
  assert.equal(this.newState, undefined, 'no transition');
});

QUnit.test('transitions to ContentPlayback on contentresumed if content resuming', function (assert) {
  this.adState.contentResuming = true;
  this.adState.onContentResumed();
  assert.equal(this.newState, 'ContentPlayback');
});

QUnit.test('doesn\'t transition on contentresumed if content not resuming', function (assert) {
  this.adState.onContentResumed();
  assert.equal(this.newState, undefined, 'no transition');
});

QUnit.test('can check if content is resuming', function (assert) {
  assert.equal(this.adState.isContentResuming(), false, 'not resuming');
  this.adState.contentResuming = true;
  assert.equal(this.adState.isContentResuming(), true, 'resuming');
});

QUnit.test('can check if in ad break', function (assert) {
  assert.equal(this.adState.inAdBreak(), false, 'not in ad break');
  this.player.ads._inLinearAdMode = true;
  assert.equal(this.adState.inAdBreak(), true, 'in ad break');
});

/*
 * These tests are intended to be isolated unit tests for one state with all
 * other modules mocked.
 */
QUnit.module('ContentState', {
  beforeEach: function beforeEach() {
    var _this = this;

    this.player = {
      ads: {
        debug: function debug() {}
      }
    };

    this.contentState = new ContentState(this.player);
    this.contentState.transitionTo = function (newState) {
      _this.newState = newState.name;
    };
  }
});

QUnit.test('is not an ad state', function (assert) {
  assert.equal(this.contentState.isAdState(), false);
});

QUnit.test('handles content changed when not playing', function (assert) {
  this.player.paused = function () {
    return true;
  };
  this.player.pause = sinon.stub();

  this.contentState.onContentChanged(this.player);
  assert.equal(this.newState, 'BeforePreroll');
  assert.equal(this.player.pause.callCount, 0, 'did not pause player');
  assert.ok(!this.player.ads._pausedOnContentupdate, 'did not set _pausedOnContentupdate');
});

QUnit.test('handles content changed when playing', function (assert) {
  this.player.paused = function () {
    return false;
  };
  this.player.pause = sinon.stub();

  this.contentState.onContentChanged(this.player);
  assert.equal(this.newState, 'Preroll');
  assert.equal(this.player.pause.callCount, 1, 'paused player');
  assert.equal(this.player.ads._pausedOnContentupdate, true, 'set _pausedOnContentupdate');
});

/*
 * These tests are intended to be isolated unit tests for one state with all
 * other modules mocked.
 */
QUnit.module('State', {
  beforeEach: function beforeEach() {
    this.player = {
      ads: {
        debug: function debug() {}
      }
    };

    this.state = new State(this.player);
  }
});

QUnit.test('sets this.player', function (assert) {
  assert.equal(this.state.player, this.player);
});

QUnit.test('can transition to another state', function (assert) {
  var mockStateInit = false;

  var MockState = function () {
    function MockState() {
      classCallCheck(this, MockState);
    }

    MockState._getName = function _getName() {
      return 'MockState';
    };

    MockState.prototype.init = function init() {
      mockStateInit = true;
    };

    return MockState;
  }();

  this.state.cleanup = sinon.stub();

  this.state.transitionTo(MockState);
  assert.ok(this.state.cleanup.calledOnce, 'cleaned up old state');
  assert.equal(this.player.ads._state.constructor.name, 'MockState', 'set ads._state');
  assert.equal(mockStateInit, true, 'initialized new state');
});

QUnit.test('throws error if isAdState is not implemented', function (assert) {
  var error = void 0;

  try {
    this.state.isAdState();
  } catch (e) {
    error = e;
  }
  assert.equal(error.message, 'isAdState unimplemented for Anonymous State');
});

QUnit.test('is not resuming content by default', function (assert) {
  assert.equal(this.state.isContentResuming(), false);
});

QUnit.test('is not in an ad break by default', function (assert) {
  assert.equal(this.state.inAdBreak(), false);
});

QUnit.test('handles events', function (assert) {
  this.state.onPlay = sinon.stub();
  this.state.handleEvent('play');
  assert.ok(this.state.onPlay.calledOnce);
});

/*
 * These tests are intended to be isolated unit tests for one state with all
 * other modules mocked.
 */
QUnit.module('AdsDone', {
  beforeEach: function beforeEach() {
    var _this = this;

    this.events = [];
    this.player = {
      trigger: function trigger(event) {
        _this.events.push(event);
      },
      ads: {}
    };

    this.adsDone = new AdsDone(this.player);
  }
});

QUnit.test('sets _contentHasEnded on init', function (assert) {
  this.adsDone.init(this.player);
  assert.equal(this.player.ads._contentHasEnded, true, 'content has ended');
});

QUnit.test('ended event on init', function (assert) {
  this.adsDone.init(this.player);
  assert.equal(this.events[0], 'ended', 'content has ended');
});

QUnit.test('does not play midrolls', function (assert) {
  this.adsDone.transitionTo = sinon.spy();

  this.adsDone.init(this.player);
  this.adsDone.startLinearAdMode();
  assert.equal(this.adsDone.transitionTo.callCount, 0, 'no transition');
});

function initCancelContentPlay(player, debug) {
  if (debug) {
    videojs$1.log('Using cancelContentPlay to block content playback');
  }

  // Listen to play events to "cancel" them afterward
  player.on('play', cancelContentPlay);
}

/*
This feature makes sure the player is paused during ad loading.

It does this by pausing the player immediately after a "play" where ads will be requested,
then signalling that we should play after the ad is done.
*/

function cancelContentPlay() {
  var player = this;

  if (player.ads._shouldBlockPlay === false) {
    // Only block play if the ad plugin is in a state when content
    // playback should be blocked. This currently means during
    // BeforePrerollState and PrerollState.
    return;
  }

  // pause playback so ads can be handled.
  if (!player.paused()) {
    player.ads.debug('Playback was canceled by cancelContentPlay');
    player.pause();
  }

  // When the 'content-playback' state is entered, this will let us know to play.
  // This is needed if there is no preroll or if it errors, times out, etc.
  player.ads._cancelledPlay = true;
}

var CancelContentPlay = (Object.freeze || Object)({
	'default': initCancelContentPlay
});

/*
 * These tests are intended to be isolated unit tests for one state with all
 * other modules mocked.
 */
QUnit.module('BeforePreroll', {
  beforeEach: function beforeEach() {
    var _this = this;

    this.events = [];

    this.player = {
      ads: {
        debug: function debug() {},
        _shouldBlockPlay: false
      },
      setTimeout: function setTimeout() {},
      trigger: function trigger(event) {
        _this.events.push(event);
      }
    };

    this.beforePreroll = new BeforePreroll(this.player);
    this.beforePreroll.transitionTo = function (newState, arg, arg2) {
      _this.newState = newState.name;
      _this.transitionArg = arg;
      _this.transitionArg2 = arg2;
    };

    this.cancelContentPlayStub = sinon.stub(CancelContentPlay, 'cancelContentPlay');
  },

  afterEach: function afterEach() {
    this.cancelContentPlayStub.restore();
  }
});

QUnit.test('transitions to Preroll (adsready first)', function (assert) {
  this.beforePreroll.init(this.player);
  assert.equal(this.beforePreroll.adsReady, false);
  this.beforePreroll.onAdsReady(this.player);
  assert.equal(this.beforePreroll.adsReady, true);
  this.beforePreroll.onPlay(this.player);
  assert.equal(this.newState, 'Preroll');
  assert.equal(this.transitionArg, true);
});

QUnit.test('transitions to Preroll (play first)', function (assert) {
  this.beforePreroll.init(this.player);
  assert.equal(this.beforePreroll.adsReady, false);
  this.beforePreroll.onPlay(this.player);
  assert.equal(this.newState, 'Preroll');
  assert.equal(this.transitionArg, false);
});

QUnit.test('cancels ads', function (assert) {
  this.beforePreroll.init(this.player);
  this.beforePreroll.onAdsCanceled(this.player);
  assert.equal(this.beforePreroll.shouldResumeToContent, true);
  this.beforePreroll.onPlay(this.player);
  assert.equal(this.newState, 'Preroll');
  assert.equal(this.transitionArg, false);
  assert.equal(this.transitionArg2, true);
});

QUnit.test('transitions to content resuming in preroll on error', function (assert) {
  this.beforePreroll.init(this.player);
  this.beforePreroll.onAdsError(this.player);
  assert.equal(this.beforePreroll.shouldResumeToContent, true);
  this.beforePreroll.onPlay(this.player);
  assert.equal(this.newState, 'Preroll');
  assert.equal(this.transitionArg, false);
  assert.equal(this.transitionArg2, true);
});

QUnit.test('has no preroll', function (assert) {
  this.beforePreroll.init(this.player);
  this.beforePreroll.onNoPreroll(this.player);
  assert.equal(this.beforePreroll.shouldResumeToContent, true);
  this.beforePreroll.onPlay(this.player);
  assert.equal(this.newState, 'Preroll');
  assert.equal(this.transitionArg, false);
  assert.equal(this.transitionArg2, true);
});

QUnit.test('skips the preroll', function (assert) {
  this.beforePreroll.init(this.player);
  this.beforePreroll.skipLinearAdMode();
  assert.equal(this.events[0], 'adskip');
  assert.equal(this.beforePreroll.shouldResumeToContent, true);
  this.beforePreroll.onPlay(this.player);
  assert.equal(this.newState, 'Preroll');
  assert.equal(this.transitionArg, false);
  assert.equal(this.transitionArg2, true);
});

QUnit.test('handles content change', function (assert) {
  sinon.spy(this.beforePreroll, "init");
  this.beforePreroll.onContentChanged(this.player);
  assert.equal(this.beforePreroll.init.calledOnce, true);
});

QUnit.test('sets _shouldBlockPlay to true', function (assert) {
  this.beforePreroll.init(this.player);
  assert.equal(this.player.ads._shouldBlockPlay, true);
});

QUnit.test('updates `shouldResumeToContent` on `nopreroll`', function (assert) {
  this.beforePreroll.init(this.player);
  this.beforePreroll.onNoPreroll();
  assert.strictEqual(this.beforePreroll.shouldResumeToContent, true);
});

QUnit.test('updates `shouldResumeToContent` on `adserror`', function (assert) {
  this.beforePreroll.init(this.player);
  this.beforePreroll.onAdsError();
  assert.strictEqual(this.beforePreroll.shouldResumeToContent, true);
});

QUnit.test('updates `shouldResumeToContent` on `adscanceled`', function (assert) {
  this.beforePreroll.init(this.player);
  this.beforePreroll.onAdsCanceled(this.player);
  assert.strictEqual(this.beforePreroll.shouldResumeToContent, true);
});

QUnit.test('updates `shouldResumeToContent` on `skipLinearAdMode`', function (assert) {
  this.beforePreroll.init(this.player);
  this.beforePreroll.skipLinearAdMode();
  assert.strictEqual(this.beforePreroll.shouldResumeToContent, true);
});

/*
 * These tests are intended to be isolated unit tests for one state with all
 * other modules mocked.
 */
QUnit.module('ContentPlayback', {
  beforeEach: function beforeEach() {
    var _this = this;

    this.events = [];
    this.playTriggered = false;

    this.player = {
      paused: function paused() {
        return false;
      },
      play: function play() {},
      trigger: function trigger(event) {
        _this.events.push(event);
      },
      ads: {
        debug: function debug() {},
        _shouldBlockPlay: true
      }
    };

    this.contentPlayback = new ContentPlayback(this.player);
    this.contentPlayback.transitionTo = function (newState) {
      _this.newState = newState.name;
    };
  }
});

QUnit.test('adsready triggers readyforpreroll', function (assert) {
  this.contentPlayback.init(this.player);
  this.contentPlayback.onAdsReady(this.player);
  assert.equal(this.events[0], 'readyforpreroll');
});

QUnit.test('no readyforpreroll if nopreroll_', function (assert) {
  this.player.ads.nopreroll_ = true;
  this.contentPlayback.init(this.player);
  this.contentPlayback.onAdsReady(this.player);
  assert.equal(this.events.length, 0, 'no events triggered');
});

QUnit.test('transitions to Postroll on readyforpostroll', function (assert) {
  this.contentPlayback.init(this.player, false);
  this.contentPlayback.onReadyForPostroll(this.player);
  assert.equal(this.newState, 'Postroll', 'transitioned to Postroll');
});

QUnit.test('transitions to Midroll on startlinearadmode', function (assert) {
  this.contentPlayback.init(this.player, false);
  this.contentPlayback.startLinearAdMode();
  assert.equal(this.newState, 'Midroll', 'transitioned to Midroll');
});

QUnit.test('sets _shouldBlockPlay to false on init', function (assert) {
  assert.equal(this.player.ads._shouldBlockPlay, true);

  this.contentPlayback.init(this.player);
  assert.equal(this.player.ads._shouldBlockPlay, false);
});

/*
 * These tests are intended to be isolated unit tests for one state with all
 * other modules mocked.
 */
QUnit.module('Midroll', {
  beforeEach: function beforeEach() {
    var _this = this;

    this.player = {
      addClass: function addClass() {},
      removeClass: function removeClass() {},
      ads: {
        _inLinearAdMode: true,
        endLinearAdMode: function endLinearAdMode() {
          _this.calledEndLinearAdMode = true;
        }
      }
    };

    this.midroll = new Midroll(this.player);

    this.adBreakStartStub = sinon.stub(obj, 'start');
    this.adBreakEndStub = sinon.stub(obj, 'end');
  },

  afterEach: function afterEach() {
    this.adBreakStartStub.restore();
    this.adBreakEndStub.restore();
  }
});

QUnit.test('starts an ad break on init', function (assert) {
  this.midroll.init(this.player);
  assert.equal(this.player.ads.adType, 'midroll', 'ad type is midroll');
  assert.equal(this.adBreakStartStub.callCount, 1, 'ad break started');
});

QUnit.test('ends an ad break on endLinearAdMode', function (assert) {
  this.midroll.init(this.player);
  this.midroll.endLinearAdMode();
  assert.equal(this.adBreakEndStub.callCount, 1, 'ad break ended');
});

QUnit.test('adserror during ad break ends ad break', function (assert) {
  this.midroll.init(this.player);
  this.midroll.onAdsError(this.player);
  assert.equal(this.calledEndLinearAdMode, true, 'linear ad mode ended');
});

/*
 * These tests are intended to be isolated unit tests for one state with all
 * other modules mocked.
 */
QUnit.module('Postroll', {
  beforeEach: function beforeEach() {
    var _this = this;

    this.events = [];

    this.player = {
      ads: {
        settings: {},
        debug: function debug() {},
        inAdBreak: function inAdBreak() {
          return false;
        }
      },
      addClass: function addClass() {},
      removeClass: function removeClass() {},
      setTimeout: function setTimeout() {},
      trigger: function trigger(event) {
        _this.events.push(event);
      },
      clearTimeout: function clearTimeout() {}
    };

    this.postroll = new Postroll(this.player);

    this.postroll.transitionTo = function (newState) {
      _this.newState = newState.name;
    };

    this.adBreakStartStub = sinon.stub(obj, 'start');
    this.adBreakEndStub = sinon.stub(obj, 'end');
  },

  afterEach: function afterEach() {
    this.adBreakStartStub.restore();
    this.adBreakEndStub.restore();
  }
});

QUnit.test('sets _contentEnding on init', function (assert) {
  this.postroll.init(this.player);
  assert.equal(this.player.ads._contentEnding, true, 'content is ending');
});

QUnit.test('startLinearAdMode starts ad break', function (assert) {
  this.postroll.init(this.player);
  this.postroll.startLinearAdMode();
  assert.equal(this.adBreakStartStub.callCount, 1, 'ad break started');
  assert.equal(this.player.ads.adType, 'postroll', 'ad type is postroll');
});

QUnit.test('removes ad loading class on ad started', function (assert) {
  this.player.removeClass = sinon.spy();
  this.postroll.init(this.player);
  this.postroll.onAdStarted(this.player);
  assert.ok(this.player.removeClass.calledWith('vjs-ad-loading'));
});

QUnit.test('ends linear ad mode & ended event on ads error', function (assert) {
  this.player.ads.endLinearAdMode = sinon.spy();

  this.postroll.init(this.player);
  this.player.ads.inAdBreak = function () {
    return true;
  };
  this.postroll.onAdsError(this.player);
  assert.equal(this.player.ads.endLinearAdMode.callCount, 1, 'linear ad mode ended');
});

QUnit.test('no endLinearAdMode on adserror if not in ad break', function (assert) {
  this.player.ads.endLinearAdMode = sinon.spy();

  this.postroll.init(this.player);
  this.player.ads.inAdBreak = function () {
    return false;
  };
  this.postroll.onAdsError(this.player);
  assert.equal(this.player.ads.endLinearAdMode.callCount, 0, 'linear ad mode ended');
});

QUnit.test('does not transition to AdsDone unless content resuming', function (assert) {
  this.postroll.init(this.player);
  this.postroll.onEnded(this.player);
  assert.equal(this.newState, undefined, 'no transition');
});

QUnit.test('transitions to BeforePreroll on content changed after ad break', function (assert) {
  this.postroll.isContentResuming = function () {
    return true;
  };
  this.postroll.init(this.player);
  this.postroll.onContentChanged(this.player);
  assert.equal(this.newState, 'BeforePreroll');
});

QUnit.test('transitions to Preroll on content changed before ad break', function (assert) {
  this.postroll.init(this.player);
  this.postroll.onContentChanged(this.player);
  assert.equal(this.newState, 'Preroll');
});

QUnit.test('doesn\'t transition on content changed during ad break', function (assert) {
  this.postroll.inAdBreak = function () {
    return true;
  };
  this.postroll.init(this.player);
  this.postroll.onContentChanged(this.player);
  assert.equal(this.newState, undefined, 'no transition');
});

QUnit.test('transitions to AdsDone on nopostroll before ad break', function (assert) {
  this.postroll.init(this.player);
  this.postroll.onNoPostroll(this.player);
  assert.equal(this.newState, 'AdsDone');
});

QUnit.test('no transition on nopostroll during ad break', function (assert) {
  this.postroll.inAdBreak = function () {
    return true;
  };
  this.postroll.init(this.player);
  this.postroll.onNoPostroll(this.player);
  assert.equal(this.newState, undefined, 'no transition');
});

QUnit.test('no transition on nopostroll after ad break', function (assert) {
  this.postroll.isContentResuming = function () {
    return true;
  };
  this.postroll.init(this.player);
  this.postroll.onNoPostroll(this.player);
  assert.equal(this.newState, undefined, 'no transition');
});

QUnit.test('can abort', function (assert) {
  var removeClassSpy = sinon.spy(this.player, 'removeClass');

  this.postroll.init(this.player);
  this.postroll.abort(this.player);
  assert.equal(this.postroll.contentResuming, true, 'contentResuming');
  assert.ok(removeClassSpy.calledWith('vjs-ad-loading'), 'loading class removed');
});

QUnit.test('can clean up', function (assert) {
  var clearSpy = sinon.spy(this.player, 'clearTimeout');

  this.postroll.init(this.player);
  this.postroll.cleanup(this.player);
  assert.equal(this.player.ads._contentEnding, false, '_contentEnding');
  assert.ok(clearSpy.calledWith(this.postroll._postrollTimeout), 'cleared timeout');
});

QUnit.test('can tell if waiting for ad break', function (assert) {
  this.postroll.init(this.player);
  assert.equal(this.postroll.isWaitingForAdBreak(), true, 'waiting for ad break');
  this.postroll.startLinearAdMode();
  assert.equal(this.postroll.isWaitingForAdBreak(), false, 'not waiting for ad break');
});

/*
 * These tests are intended to be isolated unit tests for one state with all
 * other modules mocked.
 */
QUnit.module('Preroll', {
  beforeEach: function beforeEach() {
    var _this = this;

    this.events = [];
    this.playTriggered = false;

    this.player = {
      ads: {
        debug: function debug() {},
        settings: {},
        inAdBreak: function inAdBreak() {
          return false;
        },
        isContentResuming: function isContentResuming() {
          return false;
        },
        _shouldBlockPlay: true
      },
      setTimeout: function setTimeout() {},
      clearTimeout: function clearTimeout() {},
      addClass: function addClass() {},
      removeClass: function removeClass() {},
      one: function one() {},
      trigger: function trigger(event) {
        _this.events.push(event);
      },
      paused: function paused() {},
      play: function play() {
        _this.playTriggered = true;
      }
    };

    this.preroll = new Preroll(this.player);

    this.preroll.transitionTo = function (newState, arg) {
      _this.newState = newState.name;
      _this.transitionArg = arg;
    };

    this.preroll.afterLoadStart = function (callback) {
      callback();
    };

    this.adBreakStartStub = sinon.stub(obj, 'start');
    this.adBreakEndStub = sinon.stub(obj, 'end');
  },

  afterEach: function afterEach() {
    this.adBreakStartStub.restore();
    this.adBreakEndStub.restore();
  }
});

QUnit.test('plays a preroll (adsready true)', function (assert) {
  this.preroll.init(this.player, true);
  assert.equal(this.preroll.adsReady, true, 'adsready from init');
  assert.equal(this.events[0], 'readyforpreroll', 'readyforpreroll from init');
  assert.equal(this.preroll.inAdBreak(), false, 'not in ad break');
  assert.equal(this.preroll.isWaitingForAdBreak(), true, 'waiting for ad break');

  this.preroll.startLinearAdMode();
  // Because adBreak.start is mocked.
  this.player.ads._inLinearAdMode = true;
  assert.equal(this.adBreakStartStub.callCount, 1, 'ad break started');
  assert.equal(this.player.ads.adType, 'preroll', 'adType is preroll');
  assert.equal(this.preroll.isContentResuming(), false, 'content not resuming');
  assert.equal(this.preroll.inAdBreak(), true, 'in ad break');
  assert.equal(this.preroll.isWaitingForAdBreak(), false, 'not waiting for ad break');

  this.preroll.endLinearAdMode();
  assert.equal(this.adBreakEndStub.callCount, 1, 'ad break ended');
  assert.equal(this.preroll.isContentResuming(), true, 'content resuming');
  assert.equal(this.preroll.isWaitingForAdBreak(), false, 'not waiting for ad break');

  this.preroll.onPlaying();
  assert.equal(this.newState, 'ContentPlayback', 'transitioned to ContentPlayback');
});

QUnit.test('plays a preroll (adsready false)', function (assert) {
  this.preroll.init(this.player, false);
  assert.equal(this.preroll.adsReady, false, 'not adsReady yet');

  this.preroll.onAdsReady(this.player);
  assert.equal(this.preroll.adsReady, true, 'adsready from init');
  assert.equal(this.events[0], 'readyforpreroll', 'readyforpreroll from init');
  assert.equal(this.preroll.inAdBreak(), false, 'not in ad break');
  assert.equal(this.preroll.isWaitingForAdBreak(), true, 'waiting for ad break');

  this.preroll.startLinearAdMode();
  // Because adBreak.start is mocked.
  this.player.ads._inLinearAdMode = true;
  assert.equal(this.adBreakStartStub.callCount, 1, 'ad break started');
  assert.equal(this.player.ads.adType, 'preroll', 'adType is preroll');
  assert.equal(this.preroll.isContentResuming(), false, 'content not resuming');
  assert.equal(this.preroll.inAdBreak(), true, 'in ad break');
  assert.equal(this.preroll.isWaitingForAdBreak(), false, 'not waiting for ad break');

  this.preroll.endLinearAdMode();
  assert.equal(this.adBreakEndStub.callCount, 1, 'ad break ended');
  assert.equal(this.preroll.isContentResuming(), true, 'content resuming');
  assert.equal(this.preroll.isWaitingForAdBreak(), false, 'not waiting for ad break');

  this.preroll.onPlaying();
  assert.equal(this.newState, 'ContentPlayback', 'transitioned to ContentPlayback');
});

QUnit.test('can handle nopreroll event', function (assert) {
  this.preroll.init(this.player, false, false);
  this.preroll.onNoPreroll(this.player);
  assert.equal(this.preroll.isContentResuming(), true);
  this.preroll.onPlaying(this.player);
  assert.equal(this.newState, 'ContentPlayback', 'transitioned to ContentPlayback');
});

QUnit.test('can handle adscanceled', function (assert) {
  this.preroll.init(this.player, false, false);
  this.preroll.onAdsCanceled(this.player);
  assert.equal(this.preroll.isContentResuming(), true);
  this.preroll.onPlaying(this.player);
  assert.equal(this.newState, 'ContentPlayback', 'transitioned to ContentPlayback');
});

QUnit.test('can handle adserror', function (assert) {
  this.preroll.init(this.player, false, false);
  this.preroll.onAdsError(this.player);
  assert.equal(this.preroll.isContentResuming(), true);
  this.preroll.onPlaying(this.player);
  assert.equal(this.newState, 'ContentPlayback', 'transitioned to ContentPlayback');
});

QUnit.test('can skip linear ad mode', function (assert) {
  this.preroll.init(this.player, false, false);
  this.preroll.skipLinearAdMode();
  assert.equal(this.preroll.isContentResuming(), true);
  this.preroll.onPlaying(this.player);
  assert.equal(this.newState, 'ContentPlayback', 'transitioned to ContentPlayback');
});

QUnit.test('plays content after ad timeout', function (assert) {
  this.preroll.init(this.player, false, false);
  this.preroll.onAdTimeout(this.player);
  assert.equal(this.preroll.isContentResuming(), true);
  this.preroll.onPlaying(this.player);
  assert.equal(this.newState, 'ContentPlayback', 'transitioned to ContentPlayback');
});

QUnit.test('removes ad loading class on ads started', function (assert) {
  this.preroll.init(this.player, false);

  var removeClassSpy = sinon.spy(this.player, 'removeClass');

  this.preroll.onAdStarted(this.player);
  assert.ok(removeClassSpy.calledWith('vjs-ad-loading'), 'loading class removed');
});

QUnit.test('only plays after no ad in correct conditions', function (assert) {
  this.preroll.init(this.player, false, false);

  this.player.ads._playRequested = false;
  this.player.ads._pausedOnContentupdate = false;
  this.player.paused = function () {
    return false;
  };
  this.preroll.resumeAfterNoPreroll(this.player);
  assert.equal(this.playTriggered, false, 'should not call play when playing already');

  this.player.ads._playRequested = true;
  this.player.ads._pausedOnContentupdate = false;
  this.player.paused = function () {
    return false;
  };
  this.preroll.resumeAfterNoPreroll(this.player);
  assert.equal(this.playTriggered, false, 'should not call play when playing already 2');

  this.player.ads._playRequested = false;
  this.player.ads._pausedOnContentupdate = true;
  this.player.paused = function () {
    return false;
  };
  this.preroll.resumeAfterNoPreroll(this.player);
  assert.equal(this.playTriggered, false, 'should not call play when playing already 3');

  this.player.ads._playRequested = false;
  this.player.ads._pausedOnContentupdate = false;
  this.player.paused = function () {
    return true;
  };
  this.preroll.resumeAfterNoPreroll(this.player);
  assert.equal(this.playTriggered, false, 'should not call play when playback has never started');

  this.player.ads._playRequested = true;
  this.player.ads._pausedOnContentupdate = false;
  this.player.paused = function () {
    return true;
  };
  this.preroll.resumeAfterNoPreroll(this.player);
  assert.equal(this.playTriggered, true, 'should call play when playback had been started and the player is paused');

  this.player.ads._playRequested = false;
  this.player.ads._pausedOnContentupdate = true;
  this.player.paused = function () {
    return true;
  };
  this.preroll.resumeAfterNoPreroll(this.player);
  assert.equal(this.playTriggered, true, 'should call play when playback had been started on the last source and the player is paused');
});

QUnit.test('remove ad loading class on cleanup', function (assert) {
  this.preroll.init(this.player, false);

  var removeClassSpy = sinon.spy(this.player, 'removeClass');

  this.preroll.cleanup(this.player);
  assert.ok(removeClassSpy.calledWith('vjs-ad-loading'), 'loading class removed');
});

QUnit.test('resets _shouldBlockPlay to false when ad break starts', function (assert) {
  this.preroll.init(this.player, true);
  this.preroll.startLinearAdMode();
  assert.equal(this.player.ads._shouldBlockPlay, false);
});

QUnit.test('resets _shouldBlockPlay to false when no preroll', function (assert) {
  this.preroll.init(this.player, true, false);
  this.preroll.resumeAfterNoPreroll(this.player);
  assert.equal(this.player.ads._shouldBlockPlay, false);
});

/*
 * These tests are intended to be isolated unit tests for one state with all
 * other modules mocked.
 */
QUnit.module('StitchedAdRoll', {
  beforeEach: function beforeEach() {
    this.player = {
      addClass: function addClass() {},
      removeClass: function removeClass() {},
      trigger: sinon.spy(),
      ads: {
        _inLinearAdMode: true,
        debug: function debug() {}
      }
    };

    this.adroll = new StitchedAdRoll(this.player);

    this.adBreakStartStub = sinon.stub(obj, 'start');
    this.adBreakEndStub = sinon.stub(obj, 'end');
  },

  afterEach: function afterEach() {
    this.adBreakStartStub.restore();
    this.adBreakEndStub.restore();
  }
});

QUnit.test('starts an ad break on init', function (assert) {
  this.adroll.init();
  assert.equal(this.player.ads.adType, 'stitched', 'ad type is stitched');
  assert.equal(this.adBreakStartStub.callCount, 1, 'ad break started');
});

QUnit.test('ends an ad break on endLinearAdMode', function (assert) {
  this.adroll.init();
  this.adroll.endLinearAdMode();
  assert.equal(this.adBreakEndStub.callCount, 1, 'ad break ended');
});

QUnit.test('adended during ad break leaves linear ad mode and re-triggers ended', function (assert) {
  sinon.spy(this.adroll, 'endLinearAdMode');

  this.adroll.init();
  this.adroll.onAdEnded();
  assert.ok(this.player.trigger.calledOnce, 'the player fired one event');
  assert.ok(this.player.trigger.calledWith('ended'), 'the event it fired was ended');
  assert.ok(this.adroll.endLinearAdMode.calledOnce, 'the ad roll called endLinearAdMode');
});

/*
 * These tests are intended to be isolated unit tests for one state with all
 * other modules mocked.
 */
QUnit.module('StitchedContentPlayback', {
  beforeEach: function beforeEach() {
    var _this = this;

    this.events = [];
    this.playTriggered = false;

    this.player = {
      paused: function paused() {
        return false;
      },
      play: function play() {},
      trigger: function trigger(event) {
        _this.events.push(event);
      },
      ads: {
        debug: function debug() {},
        _contentHasEnded: false,
        _shouldBlockPlay: true
      }
    };

    this.stitchedContentPlayback = new StitchedContentPlayback(this.player);
    this.stitchedContentPlayback.transitionTo = function (newState) {
      _this.newState = newState.name;
    };
  }
});

QUnit.test('transitions to StitchedAdRoll when startLinearAdMode is called', function (assert) {
  this.stitchedContentPlayback.init();
  this.stitchedContentPlayback.startLinearAdMode();
  assert.equal(this.newState, 'StitchedAdRoll', 'transitioned to StitchedAdRoll');
});

QUnit.test('sets _shouldBlockPlay to false on init', function (assert) {
  assert.equal(this.player.ads._shouldBlockPlay, true);

  this.stitchedContentPlayback.init();
  assert.equal(this.player.ads._shouldBlockPlay, false);
});

var version = "6.6.1";

/*
 * Implements the public API available in `player.ads` as well as application state.
 */

function getAds(player) {
  return {

    disableNextSnapshotRestore: false,

    // This is true if we have finished actual content playback but haven't
    // dealt with postrolls and officially ended yet
    _contentEnding: false,

    // This is set to true if the content has officially ended at least once.
    // After that, the user can seek backwards and replay content, but _contentHasEnded
    // remains true.
    _contentHasEnded: false,

    // Tracks if loadstart has happened yet for the initial source. It is not reset
    // on source changes because loadstart is the event that signals to the ad plugin
    // that the source has changed. Therefore, no special signaling is needed to know
    // that there has been one for subsequent sources.
    _hasThereBeenALoadStartDuringPlayerLife: false,

    // Tracks if loadeddata has happened yet for the current source.
    _hasThereBeenALoadedData: false,

    // Tracks if loadedmetadata has happened yet for the current source.
    _hasThereBeenALoadedMetaData: false,

    // Are we after startLinearAdMode and before endLinearAdMode?
    _inLinearAdMode: false,

    // Should we block calls to play on the content player?
    _shouldBlockPlay: false,

    // Was play blocked by the plugin's playMiddleware feature?
    _playBlocked: false,

    // Tracks whether play has been requested for this source,
    // either by the play method or user interaction
    _playRequested: false,

    // This is an estimation of the current ad type being played
    // This is experimental currently. Do not rely on its presence or behavior!
    adType: null,

    VERSION: version,

    reset: function reset() {
      player.ads.disableNextSnapshotRestore = false;
      player.ads._contentEnding = false;
      player.ads._contentHasEnded = false;
      player.ads.snapshot = null;
      player.ads.adType = null;
      player.ads._hasThereBeenALoadedData = false;
      player.ads._hasThereBeenALoadedMetaData = false;
      player.ads._cancelledPlay = false;
      player.ads._shouldBlockPlay = false;
      player.ads._playBlocked = false;
      player.ads.nopreroll_ = false;
      player.ads.nopostroll_ = false;
      player.ads._playRequested = false;
    },


    // Call this when an ad response has been received and there are
    // linear ads ready to be played.
    startLinearAdMode: function startLinearAdMode() {
      player.ads._state.startLinearAdMode();
    },


    // Call this when a linear ad pod has finished playing.
    endLinearAdMode: function endLinearAdMode() {
      player.ads._state.endLinearAdMode();
    },


    // Call this when an ad response has been received but there are no
    // linear ads to be played (i.e. no ads available, or overlays).
    // This has no effect if we are already in an ad break.  Always
    // use endLinearAdMode() to exit from linear ad-playback state.
    skipLinearAdMode: function skipLinearAdMode() {
      player.ads._state.skipLinearAdMode();
    },


    // With no arguments, returns a boolean value indicating whether or not
    // contrib-ads is set to treat ads as stitched with content in a single
    // stream. With arguments, treated as a setter, but this behavior is
    // deprecated.
    stitchedAds: function stitchedAds(arg) {
      if (arg !== undefined) {
        videojs$1.log.warn('Using player.ads.stitchedAds() as a setter is deprecated, ' + 'it should be set as an option upon initialization of contrib-ads.');

        // Keep the private property and the settings in sync. When this
        // setter is removed, we can probably stop using the private property.
        this.settings.stitchedAds = !!arg;
      }

      return this.settings.stitchedAds;
    },


    // Returns whether the video element has been modified since the
    // snapshot was taken.
    // We test both src and currentSrc because changing the src attribute to a URL that
    // AdBlocker is intercepting doesn't update currentSrc.
    videoElementRecycled: function videoElementRecycled() {
      if (player.ads.shouldPlayContentBehindAd(player)) {
        return false;
      }

      if (!this.snapshot) {
        throw new Error('You cannot use videoElementRecycled while there is no snapshot.');
      }

      var srcChanged = player.tech_.src() !== this.snapshot.src;
      var currentSrcChanged = player.currentSrc() !== this.snapshot.currentSrc;

      return srcChanged || currentSrcChanged;
    },


    // Returns a boolean indicating if given player is in live mode.
    // One reason for this: https://github.com/videojs/video.js/issues/3262
    // Also, some live content can have a duration.
    isLive: function isLive() {
      var somePlayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : player;

      if (typeof somePlayer.ads.settings.contentIsLive === 'boolean') {
        return somePlayer.ads.settings.contentIsLive;
      } else if (somePlayer.duration() === Infinity) {
        return true;
      } else if (videojs$1.browser.IOS_VERSION === '8' && somePlayer.duration() === 0) {
        return true;
      }
      return false;
    },


    // Return true if content playback should mute and continue during ad breaks.
    // This is only done during live streams on platforms where it's supported.
    // This improves speed and accuracy when returning from an ad break.
    shouldPlayContentBehindAd: function shouldPlayContentBehindAd() {
      var somePlayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : player;

      if (!somePlayer) {
        throw new Error('shouldPlayContentBehindAd requires a player as a param');
      } else if (!somePlayer.ads.settings.liveCuePoints) {
        return false;
      } else {
        return !videojs$1.browser.IS_IOS && !videojs$1.browser.IS_ANDROID && somePlayer.duration() === Infinity;
      }
    },


    // Return true if the ads plugin should save and restore snapshots of the
    // player state when moving into and out of ad mode.
    shouldTakeSnapshots: function shouldTakeSnapshots() {
      var somePlayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : player;

      return !this.shouldPlayContentBehindAd(somePlayer) && !this.stitchedAds();
    },


    // Returns true if player is in ad mode.
    //
    // Ad mode definition:
    // If content playback is blocked by the ad plugin.
    //
    // Examples of ad mode:
    //
    // * Waiting to find out if an ad is going to play while content would normally be
    //   playing.
    // * Waiting for an ad to start playing while content would normally be playing.
    // * An ad is playing (even if content is also playing)
    // * An ad has completed and content is about to resume, but content has not resumed
    //   yet.
    //
    // Examples of not ad mode:
    //
    // * Content playback has not been requested
    // * Content playback is paused
    // * An asynchronous ad request is ongoing while content is playing
    // * A non-linear ad is active
    isInAdMode: function isInAdMode() {
      return this._state.isAdState();
    },


    // Returns true if in ad mode but an ad break hasn't started yet.
    isWaitingForAdBreak: function isWaitingForAdBreak() {
      return this._state.isWaitingForAdBreak();
    },


    // Returns true if content is resuming after an ad. This is part of ad mode.
    isContentResuming: function isContentResuming() {
      return this._state.isContentResuming();
    },


    // Deprecated because the name was misleading. Use inAdBreak instead.
    isAdPlaying: function isAdPlaying() {
      return this._state.inAdBreak();
    },


    // Returns true if an ad break is ongoing. This is part of ad mode.
    // An ad break is the time between startLinearAdMode and endLinearAdMode.
    inAdBreak: function inAdBreak() {
      return this._state.inAdBreak();
    },


    /*
     * Remove the poster attribute from the video element tech, if present. When
     * reusing a video element for multiple videos, the poster image will briefly
     * reappear while the new source loads. Removing the attribute ahead of time
     * prevents the poster from showing up between videos.
     *
     * @param {Object} player The videojs player object
     */
    removeNativePoster: function removeNativePoster() {
      var tech = player.$('.vjs-tech');

      if (tech) {
        tech.removeAttribute('poster');
      }
    },
    debug: function debug() {
      if (this.settings.debug) {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 1 && typeof args[0] === 'string') {
          videojs$1.log('ADS: ' + args[0]);
        } else {
          videojs$1.log.apply(videojs$1, ['ADS:'].concat(args));
        }
      }
    }
  };
}

QUnit.module('Ads Object', {
  beforeEach: function beforeEach() {
    this.player = {
      currentSrc: function currentSrc() {},
      duration: function duration() {},
      on: function on() {},
      one: function one() {},
      ready: function ready() {},
      setTimeout: function setTimeout() {}
    };
    this.player.ads = getAds(this.player);
    this.player.ads.settings = {};
  }
}, function () {

  /*
   * Basic live detection
   */
  QUnit.test('isLive', function (assert) {
    this.player.duration = function () {
      return 5;
    };
    assert.equal(this.player.ads.isLive(this.player), false);

    this.player.duration = function () {
      return Infinity;
    };
    assert.equal(this.player.ads.isLive(this.player), true);
  });

  /*
   * `contentIsLive` setting overrides live detection
   */
  QUnit.test('isLive and contentIsLive', function (assert) {
    this.player.duration = function () {
      return 5;
    };
    this.player.ads.settings.contentIsLive = true;
    assert.equal(this.player.ads.isLive(this.player), true);

    this.player.duration = function () {
      return 5;
    };
    this.player.ads.settings.contentIsLive = false;
    assert.equal(this.player.ads.isLive(this.player), false);

    this.player.duration = function () {
      return Infinity;
    };
    this.player.ads.settings.contentIsLive = true;
    assert.equal(this.player.ads.isLive(this.player), true);

    this.player.duration = function () {
      return Infinity;
    };
    this.player.ads.settings.contentIsLive = false;
    assert.equal(this.player.ads.isLive(this.player), false);
  });

  QUnit.test('stitchedAds', function (assert) {
    assert.notOk(this.player.ads.stitchedAds());

    this.player.ads.settings.stitchedAds = true;

    assert.ok(this.player.ads.stitchedAds());

    sinon.spy(videojs$1.log, 'warn');
    this.player.ads.stitchedAds(false);

    assert.ok(videojs$1.log.warn.calledOnce, 'using as a setter is deprecated');
    assert.notOk(this.player.ads.stitchedAds());
    assert.notOk(this.player.ads.settings.stitchedAds);

    videojs$1.log.warn.restore();
  });

  QUnit.test('shouldPlayContentBehindAd', function (assert) {

    // liveCuePoints true + finite duration
    this.player.ads.settings.liveCuePoints = true;
    this.player.duration = function () {
      return 60;
    };
    videojs$1.browser.IS_IOS = false;
    videojs$1.browser.IS_ANDROID = false;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), false);

    this.player.ads.settings.liveCuePoints = true;
    this.player.duration = function () {
      return 60;
    };
    videojs$1.browser.IS_IOS = true;
    videojs$1.browser.IS_ANDROID = false;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), false);

    this.player.ads.settings.liveCuePoints = true;
    this.player.duration = function () {
      return 60;
    };
    videojs$1.browser.IS_IOS = false;
    videojs$1.browser.IS_ANDROID = true;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), false);

    // liveCuePoints true + infinite duration
    this.player.ads.settings.liveCuePoints = true;
    this.player.duration = function () {
      return Infinity;
    };
    videojs$1.browser.IS_IOS = false;
    videojs$1.browser.IS_ANDROID = false;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), true);

    this.player.ads.settings.liveCuePoints = true;
    this.player.duration = function () {
      return Infinity;
    };
    videojs$1.browser.IS_IOS = true;
    videojs$1.browser.IS_ANDROID = false;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), false);

    this.player.ads.settings.liveCuePoints = true;
    this.player.duration = function () {
      return Infinity;
    };
    videojs$1.browser.IS_IOS = false;
    videojs$1.browser.IS_ANDROID = true;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), false);

    // liveCuePoints false + finite duration
    this.player.ads.settings.liveCuePoints = false;
    this.player.duration = function () {
      return 60;
    };
    videojs$1.browser.IS_IOS = false;
    videojs$1.browser.IS_ANDROID = false;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), false);

    this.player.ads.settings.liveCuePoints = false;
    this.player.duration = function () {
      return 60;
    };
    videojs$1.browser.IS_IOS = true;
    videojs$1.browser.IS_ANDROID = false;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), false);

    this.player.ads.settings.liveCuePoints = false;
    this.player.duration = function () {
      return 60;
    };
    videojs$1.browser.IS_IOS = false;
    videojs$1.browser.IS_ANDROID = true;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), false);

    // liveCuePoints false + infinite duration
    this.player.ads.settings.liveCuePoints = false;
    this.player.duration = function () {
      return Infinity;
    };
    videojs$1.browser.IS_IOS = false;
    videojs$1.browser.IS_ANDROID = false;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), false);

    this.player.ads.settings.liveCuePoints = false;
    this.player.duration = function () {
      return Infinity;
    };
    videojs$1.browser.IS_IOS = true;
    videojs$1.browser.IS_ANDROID = false;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), false);

    this.player.ads.settings.liveCuePoints = false;
    this.player.duration = function () {
      return Infinity;
    };
    videojs$1.browser.IS_IOS = false;
    videojs$1.browser.IS_ANDROID = true;
    assert.equal(this.player.ads.shouldPlayContentBehindAd(this.player), false);
  });

  QUnit.test('shouldTakeSnapshots', function (assert) {
    this.player.ads.shouldPlayContentBehindAd = function () {
      return false;
    };
    this.player.ads.stitchedAds = function () {
      return false;
    };

    assert.ok(this.player.ads.shouldTakeSnapshots());

    this.player.ads.shouldPlayContentBehindAd = function () {
      return true;
    };

    assert.notOk(this.player.ads.shouldTakeSnapshots());

    this.player.ads.shouldPlayContentBehindAd = function () {
      return false;
    };
    this.player.ads.stitchedAds = function () {
      return true;
    };

    assert.notOk(this.player.ads.shouldTakeSnapshots());
  });
});

var obj$1 = {};
// This reference allows videojs to be mocked in unit tests
// while still using the available videojs import in the source code
// @see obj.testHook
var videojsReference = videojs$1;

/**
 * Checks if middleware mediators are available and
 * can be used on this platform.
 * Currently we can only use mediators on desktop platforms.
 */
obj$1.isMiddlewareMediatorSupported = function () {

  if (videojsReference.browser.IS_IOS || videojsReference.browser.IS_ANDROID) {
    return false;
  } else if (
  // added when middleware was introduced in video.js
  videojsReference.use &&
  // added when mediators were introduced in video.js
  videojsReference.middleware && videojsReference.middleware.TERMINATOR) {
    return true;
  }

  return false;
};

obj$1.playMiddleware = function (player) {
  return {
    setSource: function setSource(srcObj, next) {
      next(null, srcObj);
    },
    callPlay: function callPlay() {
      // Block play calls while waiting for an ad, only if this is an
      // ad supported player
      if (player.ads && player.ads._shouldBlockPlay === true) {
        player.ads.debug('Using playMiddleware to block content playback');
        player.ads._playBlocked = true;
        return videojsReference.middleware.TERMINATOR;
      }
    },
    play: function play(terminated, playPromise) {
      if (player.ads && player.ads._playBlocked && terminated) {
        player.ads.debug('Play call to Tech was terminated.');
        // Trigger play event to match the user's intent to play.
        // The call to play on the Tech has been blocked, so triggering
        // the event on the Player will not affect the Tech's playback state.
        player.trigger('play');
        // At this point the player has technically started
        player.addClass('vjs-has-started');
        // Reset playBlocked
        player.ads._playBlocked = false;

        // Safari issues a pause event when autoplay is blocked but Chrome does not.
        // We fingerprint Chrome using e.message and send a pause for consistency.
        // This keeps the play button synchronized if play is rejected.
      } else if (playPromise && playPromise['catch']) {
        playPromise['catch'](function (e) {
          if (e.message === 'play() failed because the user didn\'t interact with the ' + 'document first. https://goo.gl/xX8pDD') {
            player.trigger('pause');
          }
        });
      }
    }
  };
};

obj$1.testHook = function (testVjs) {
  videojsReference = testVjs;
};

QUnit.module('Play Middleware', {}, function () {
  var baseMockedVjsNotSupported = {
    use: function use() {},
    VERSION: '5.0.0',
    browser: {}
  };

  var baseMockedVjsIsSupported = {
    use: function use() {},
    VERSION: '6.7.3',
    browser: {
      IS_IOS: false,
      IS_ANDROID: false
    },
    middleware: {
      TERMINATOR: new Object('fake terminator')
    }
  };

  QUnit.module('Not supported unit tests', {
    beforeEach: function beforeEach() {
      this.videojs = videojs.mergeOptions({}, baseMockedVjsNotSupported);
    },
    afterEach: function afterEach() {
      this.videojs = null;
    }
  }, function () {
    QUnit.test('isMiddlewareMediatorSupported is false if old video.js version', function (assert) {
      // Mock videojs.browser to mock an older videojs version
      obj$1.testHook(this.videojs);

      assert.equal(obj$1.isMiddlewareMediatorSupported(), false, 'old video.js does not support middleware mediators');
    });

    QUnit.test('isMiddlewareMediatorSupported is false if on mobile', function (assert) {
      // Mock videojs.browser to fake being on Android
      this.videojs.browser.IS_ANDROID = true;
      this.videojs.browser.IS_IOS = false;
      obj$1.testHook(this.videojs);

      assert.equal(obj$1.isMiddlewareMediatorSupported(), false, 'is not supported on Android');

      // Mock videojs.browser to fake being on iOS
      this.videojs.browser.IS_ANDROID = false;
      this.videojs.browser.IS_IOS = true;
      obj$1.testHook(this.videojs);

      assert.equal(obj$1.isMiddlewareMediatorSupported(), false, 'is not supported on iOS');
    });
  });

  QUnit.module('Supported unit tests', {
    beforeEach: function beforeEach() {
      var _this = this;

      // Stub videojs to force playMiddleware to be used
      this.videojs = videojs.mergeOptions({}, baseMockedVjsIsSupported);
      obj$1.testHook(this.videojs);

      this.triggeredEvent = null;
      this.addedClass = null;

      // Stub the player
      this.player = {
        ads: {
          _shouldBlockPlay: false,
          _playBlocked: false,
          debug: function debug() {}
        },
        trigger: function trigger(event) {
          _this.triggeredEvent = event;
        },
        addClass: function addClass(className) {
          _this.addedClass = className;
        }
      };

      this.sandbox = sinon.sandbox.create();
    },
    afterEach: function afterEach() {
      // Reset variables
      this.videojs = null;
      this.sandbox.restore();
    }
  });

  QUnit.test('isMiddlewareMediatorSupported is true if middleware mediators exist on desktop', function (assert) {
    assert.equal(obj$1.isMiddlewareMediatorSupported(), true, 'is supported if middleware mediators exist and not mobile');
  });

  QUnit.test('playMiddleware returns with a setSource, callPlay and play method', function (assert) {
    var m = obj$1.playMiddleware(this.player);

    this.sandbox.stub(obj$1, 'isMiddlewareMediatorSupported').returns(true);
    assert.equal(typeof m === 'undefined' ? 'undefined' : _typeof(m), 'object', 'returns an object');
    assert.equal(_typeof(m.setSource), 'function', 'has setSource');
    assert.equal(_typeof(m.callPlay), 'function', 'has callPlay');
    assert.equal(_typeof(m.play), 'function', 'has play');
  });

  QUnit.test('playMiddleware callPlay will terminate if _shouldBlockPlay is true', function (assert) {
    var m = obj$1.playMiddleware(this.player);

    this.sandbox.stub(obj$1, 'isMiddlewareMediatorSupported').returns(true);
    this.player.ads._shouldBlockPlay = true;
    assert.equal(m.callPlay(), this.videojs.middleware.TERMINATOR, 'callPlay returns terminator');
    assert.strictEqual(this.player.ads._playBlocked, true, '_playBlocked is set');
  });

  QUnit.test('playMiddleware callPlay will not terminate if _shouldBlockPlay is false', function (assert) {
    var m = obj$1.playMiddleware(this.player);

    this.sandbox.stub(obj$1, 'isMiddlewareMediatorSupported').returns(true);
    this.player.ads._shouldBlockPlay = false;

    assert.equal(m.callPlay(), undefined, 'callPlay should not return an object');
    assert.notEqual(m.callPlay(), this.videojs.middleware.TERMINATOR, 'callPlay should not return the terminator');
    assert.strictEqual(this.player.ads._playBlocked, false, '_playBlocked should not be set');
  });

  QUnit.test("playMiddleware callPlay will not terminate if the player doesn't have this plugin", function (assert) {
    var _this2 = this;

    var nonAdsPlayer = {
      trigger: function trigger(event) {
        _this2.triggeredEvent = event;
      },
      addClass: function addClass(className) {
        _this2.addedClass = className;
      }
    };
    var m = obj$1.playMiddleware(nonAdsPlayer);

    this.sandbox.stub(obj$1, 'isMiddlewareMediatorSupported').returns(true);
    this.player.ads._shouldBlockPlay = true;

    assert.equal(m.callPlay(), undefined, 'callPlay should not return an object');
    assert.strictEqual(this.player.ads._playBlocked, false, '_playBlocked should not be set');
  });

  QUnit.test('playMiddleware play will trigger play event if callPlay terminates', function (assert) {
    var m = obj$1.playMiddleware(this.player);

    this.sandbox.stub(obj$1, 'isMiddlewareMediatorSupported').returns(true);
    this.player.ads._shouldBlockPlay = true;
    // Mock that the callPlay method terminated
    this.player.ads._playBlocked = true;

    // Play terminates, there's no value returned
    m.play(true, null);
    assert.equal(this.triggeredEvent, 'play');
    assert.equal(this.addedClass, 'vjs-has-started');
    assert.equal(this.player.ads._playBlocked, false, '_playBlocked is reset');
  });

  QUnit.test("playMiddleware play will not trigger play event if another middleware terminated", function (assert) {
    var m = obj$1.playMiddleware(this.player);

    this.sandbox.stub(obj$1, 'isMiddlewareMediatorSupported').returns(true);
    // Mock that another middleware terminated but the playMiddleware did not
    this.player.ads._shouldBlockPlay = true;
    this.player.ads._playBlocked = false;
    this.sandbox.stub(m, 'callPlay').returns(undefined);

    // Another middleware terminated so the first argument is true
    m.play(true, null);
    assert.equal(this.triggeredEvent, null, 'no events should be triggered');
    assert.equal(this.addedClass, null, 'no classes should be added');
    assert.equal(this.player.ads._playBlocked, false, '_playBlocked has not changed');
  });

  QUnit.test("playMiddleware play will not trigger play event if the player doesn't have this plugin", function (assert) {
    var evt = null;
    var cnm = null;
    var nonAdsPlayer = {
      trigger: function trigger(event) {
        evt = event;
      },
      addClass: function addClass(className) {
        cnm = className;
      }
    };
    var m = obj$1.playMiddleware(nonAdsPlayer);

    this.sandbox.stub(obj$1, 'isMiddlewareMediatorSupported').returns(true);

    m.play(true, null);
    assert.equal(evt, null, 'the play event should not have been triggered');
    assert.equal(cnm, null, 'the class should not have been added');
  });

  QUnit.test("playMiddleware won't trigger play event if callPlay doesn't terminate", function (assert) {
    var m = obj$1.playMiddleware(this.player);
    var originalPlayBlocked = this.player.ads._playBlocked;

    this.sandbox.stub(obj$1, 'isMiddlewareMediatorSupported').returns(true);
    m.play(false, {});
    assert.equal(this.triggeredEvent, null, 'no events should be triggered');
    assert.equal(this.addedClass, null, 'no classes should be added');
    assert.strictEqual(this.player.ads._playBlocked, originalPlayBlocked, '_playBlocked remains unchanged');
  });
});

/*
The goal of this feature is to make player events work as an integrator would
expect despite the presense of ads. For example, an integrator would expect
an `ended` event to happen once the content is ended. If an `ended` event is sent
as a result of a preroll ending, that is a bug. The `redispatch` method should recognize
such `ended` events and prefix them so they are sent as `adended`, and so on with
all other player events.
*/

// Cancel an event.
// Video.js wraps native events. This technique stops propagation for the Video.js event
// (AKA player event or wrapper event) while native events continue propagating.
var cancelEvent = function cancelEvent(player, event) {
  event.isImmediatePropagationStopped = function () {
    return true;
  };
  event.cancelBubble = true;
  event.isPropagationStopped = function () {
    return true;
  };
};

// Redispatch an event with a prefix.
// Cancels the event, then sends a new event with the type of the original
// event with the given prefix added.
// The inclusion of the "state" property should be removed in a future
// major version update with instructions to migrate any code that relies on it.
// It is an implementation detail and relying on it creates fragility.
var prefixEvent = function prefixEvent(player, prefix, event) {
  cancelEvent(player, event);
  player.trigger({
    type: prefix + event.type,
    originalEvent: event
  });
};

// Playing event
// Requirements:
// * Normal playing event when there is no preroll
// * No playing event before preroll
// * At least one playing event after preroll
var handlePlaying = function handlePlaying(player, event) {
  if (player.ads.isInAdMode()) {

    if (player.ads.isContentResuming()) {

      // Prefix playing event when switching back to content after postroll.
      if (player.ads._contentEnding) {
        prefixEvent(player, 'content', event);
      }

      // Prefix all other playing events during ads.
    } else {
      prefixEvent(player, 'ad', event);
    }
  }
};

// Ended event
// Requirements:
// * A single ended event when there is no postroll
// * No ended event before postroll
// * A single ended event after postroll
var handleEnded = function handleEnded(player, event) {
  if (player.ads.isInAdMode()) {

    // Cancel ended events during content resuming. Normally we would
    // prefix them, but `contentended` has a special meaning. In the
    // future we'd like to rename the existing `contentended` to
    // `readyforpostroll`, then we could remove the special `resumeended`
    // and do a conventional content prefix here.
    if (player.ads.isContentResuming()) {
      cancelEvent(player, event);

      // Important: do not use this event outside of videojs-contrib-ads.
      // It will be removed and your code will break.
      // Ideally this would simply be `contentended`, but until
      // `contentended` no longer has a special meaning it cannot be
      // changed.
      player.trigger('resumeended');

      // Ad prefix in ad mode
    } else {
      prefixEvent(player, 'ad', event);
    }

    // Prefix ended due to content ending before postroll check
  } else if (!player.ads._contentHasEnded && !player.ads.stitchedAds()) {

    // This will change to cancelEvent after the contentended deprecation
    // period (contrib-ads 7)
    prefixEvent(player, 'content', event);

    // Content ended for the first time, time to check for postrolls
    player.trigger('readyforpostroll');
  }
};

// handleLoadEvent is used for loadstart, loadeddata, and loadedmetadata
// Requirements:
// * Initial event is not prefixed
// * Event due to ad loading is prefixed
// * Event due to content source change is not prefixed
// * Event due to content resuming is prefixed
var handleLoadEvent = function handleLoadEvent(player, event) {

  // Initial event
  if (event.type === 'loadstart' && !player.ads._hasThereBeenALoadStartDuringPlayerLife || event.type === 'loadeddata' && !player.ads._hasThereBeenALoadedData || event.type === 'loadedmetadata' && !player.ads._hasThereBeenALoadedMetaData) {
    return;

    // Ad playing
  } else if (player.ads.inAdBreak()) {
    prefixEvent(player, 'ad', event);

    // Source change
  } else if (player.currentSrc() !== player.ads.contentSrc) {
    return;

    // Content resuming
  } else {
    prefixEvent(player, 'content', event);
  }
};

// Play event
// Requirements:
// * Play events have the "ad" prefix when an ad is playing
// * Play events have the "content" prefix when content is resuming
// Play requests are unique because they represent user intention to play. They happen
// because the user clicked play, or someone called player.play(), etc. It could happen
// multiple times during ad loading, regardless of where we are in the process. With our
// current architecture, this could cause the content to start playing.
// Therefore, contrib-ads must always either:
//   - cancelContentPlay if there is any possible chance the play caused the
//     content to start playing, even if we are technically in ad mode. In order for
//     that to happen, play events need to be unprefixed until the last possible moment.
//   - use playMiddleware to stop the play from reaching the Tech so there is no risk
//     of the content starting to play.
// Currently, playMiddleware is only supported on desktop browsers with
// video.js after version 6.7.1.
var handlePlay = function handlePlay(player, event) {
  if (player.ads.inAdBreak()) {
    prefixEvent(player, 'ad', event);

    // Content resuming
  } else if (player.ads.isContentResuming()) {
    prefixEvent(player, 'content', event);
  }
};

// Handle a player event, either by redispatching it with a prefix, or by
// letting it go on its way without any meddling.
function redispatch(event) {

  // Events with special treatment
  if (event.type === 'playing') {
    handlePlaying(this, event);
  } else if (event.type === 'ended') {
    handleEnded(this, event);
  } else if (event.type === 'loadstart' || event.type === 'loadeddata' || event.type === 'loadedmetadata') {
    handleLoadEvent(this, event);
  } else if (event.type === 'play') {
    handlePlay(this, event);

    // Standard handling for all other events
  } else if (this.ads.isInAdMode()) {
    if (this.ads.isContentResuming()) {

      // Event came from snapshot restore after an ad, use "content" prefix
      prefixEvent(this, 'content', event);
    } else {

      // Event came from ad playback, use "ad" prefix
      prefixEvent(this, 'ad', event);
    }
  }
}

QUnit.module('Redispatch', {
  beforeEach: function beforeEach(assert) {

    // Player event buffer.
    // Mocked player pushes events here when they are triggered.
    // redispatch helper returns event buffer after each redispatch.
    var eventBuffer = [];

    // Mocked player
    this.player = {
      trigger: function trigger(event) {
        eventBuffer.push(event);
      },
      currentSrc: function currentSrc() {
        return 'my vid';
      },


      ads: {
        snapshot: {
          ended: false,
          currentSrc: 'my vid'
        },

        videoElementRecycled: function videoElementRecycled() {
          return false;
        },
        stitchedAds: function stitchedAds() {
          return false;
        },
        isResumingAfterNoPreroll: function isResumingAfterNoPreroll() {
          return false;
        }
      }
    };

    // Redispatch helper for tests
    this.redispatch = function (type) {
      var event = { type: type };

      eventBuffer = [];
      redispatch.call(this.player, event);

      if (eventBuffer.length === 1) {
        return eventBuffer[0].type;
      } else if (event.cancelBubble) {
        return 'cancelled';
      } else if (eventBuffer.length === 0) {
        return 'ignored';
      } else {
        throw new Error('Event buffer has more than 1 event');
      }
    };
  },
  afterEach: function afterEach(assert) {
    // Cleanup
    this.player = null;
    this.redispatch = null;
  }
});

QUnit.test('playing event in different ad states', function (assert) {

  this.player.ads.isInAdMode = function () {
    return false;
  };
  this.player.ads.isContentResuming = function () {
    return false;
  };
  assert.equal(this.redispatch('playing'), 'ignored');

  this.player.ads.isInAdMode = function () {
    return true;
  };
  this.player.ads.isContentResuming = function () {
    return false;
  };
  assert.equal(this.redispatch('playing'), 'adplaying');

  this.player.ads.isInAdMode = function () {
    return true;
  };
  this.player.ads.isContentResuming = function () {
    return true;
  };
  assert.equal(this.redispatch('playing'), 'ignored');
});

QUnit.test('play events in different states', function (assert) {
  this.player.ads.inAdBreak = function () {
    return false;
  };
  this.player.ads.isInAdMode = function () {
    return true;
  };
  this.player.ads.isContentResuming = function () {
    return true;
  };
  assert.equal(this.redispatch('play'), 'contentplay', 'should be contentplay when content is resuming');

  this.player.ads.inAdBreak = function () {
    return false;
  };
  this.player.ads.isInAdMode = function () {
    return false;
  };
  this.player.ads.isContentResuming = function () {
    return false;
  };
  this.player.ads._playRequested = false;
  assert.strictEqual(this.redispatch('play'), 'ignored', "should not be redispatched if play hasn't been requested yet");

  this.player.ads.inAdBreak = function () {
    return false;
  };
  this.player.ads.isInAdMode = function () {
    return false;
  };
  this.player.ads.isContentResuming = function () {
    return false;
  };
  this.player.ads._playRequested = true;
  assert.strictEqual(this.redispatch('play'), 'ignored', 'should not be redispatched if in content state');

  this.player.ads.inAdBreak = function () {
    return false;
  };
  this.player.ads.isInAdMode = function () {
    return true;
  };
  this.player.ads.isContentResuming = function () {
    return false;
  };
  this.player.ads._playRequested = true;
  assert.strictEqual(this.redispatch('play'), 'ignored', 'should not prefix when not in an ad break');

  this.player.ads.inAdBreak = function () {
    return true;
  };
  this.player.ads.isInAdMode = function () {
    return true;
  };
  this.player.ads.isContentResuming = function () {
    return false;
  };
  this.player.ads._playRequested = true;
  assert.strictEqual(this.redispatch('play'), 'adplay', 'should be adplay when in an ad break');
});

/*
This feature sends a `contentupdate` event when the player source changes.
*/

// Start sending contentupdate events
function initializeContentupdate(player) {

  // Keep track of the current content source
  // If you want to change the src of the video without triggering
  // the ad workflow to restart, you can update this variable before
  // modifying the player's source
  player.ads.contentSrc = player.currentSrc();

  player.ads._seenInitialLoadstart = false;

  // Check if a new src has been set, if so, trigger contentupdate
  var checkSrc = function checkSrc() {
    if (!player.ads.inAdBreak()) {
      var src = player.currentSrc();

      if (src !== player.ads.contentSrc) {

        if (player.ads._seenInitialLoadstart) {
          player.trigger({
            type: 'contentchanged'
          });
        }

        player.trigger({
          type: 'contentupdate',
          oldValue: player.ads.contentSrc,
          newValue: src
        });
        player.ads.contentSrc = src;
      }

      player.ads._seenInitialLoadstart = true;
    }
  };

  // loadstart reliably indicates a new src has been set
  player.on('loadstart', checkSrc);
}

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof commonjsGlobal !== "undefined") {
    win = commonjsGlobal;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

var window_1 = win;

var empty = {};


var empty$1 = (Object.freeze || Object)({
	'default': empty
});

var minDoc = ( empty$1 && empty ) || empty$1;

var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal :
    typeof window !== 'undefined' ? window : {};


var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

var document_1 = doccy;

/*
This feature provides an optional method for ad plugins to insert run-time values
into an ad server URL or configuration.
*/

// Return URI encoded version of value if uriEncode is true
var uriEncodeIfNeeded = function uriEncodeIfNeeded(value, uriEncode) {
  if (uriEncode) {
    return encodeURIComponent(value);
  }
  return value;
};

// Add custom field macros to macros object
// based on given name for custom fields property of mediainfo object.
var customFields = function customFields(mediainfo, macros, customFieldsName) {
  if (mediainfo && mediainfo[customFieldsName]) {
    var fields = mediainfo[customFieldsName];
    var fieldNames = Object.keys(fields);

    for (var i = 0; i < fieldNames.length; i++) {
      var tag = '{mediainfo.' + customFieldsName + '.' + fieldNames[i] + '}';

      macros[tag] = fields[fieldNames[i]];
    }
  }
};

// Public method that ad plugins use for ad macros.
// "string" is any string with macros to be replaced
// "uriEncode" if true will uri encode macro values when replaced
// "customMacros" is a object with custom macros and values to map them to
//  - For example: {'{five}': 5}
// Return value is is "string" with macros replaced
//  - For example: adMacroReplacement('{player.id}') returns a string of the player id
function adMacroReplacement(string, uriEncode, customMacros) {
  var _this = this;

  var defaults$$1 = {};

  // Get macros with defaults e.g. {x=y}, store values and replace with standard macros
  string = string.replace(/{([^}=]+)=([^}]+)}/g, function (match, name, defaultVal) {
    defaults$$1['{' + name + '}'] = defaultVal;

    return '{' + name + '}';
  });

  if (uriEncode === undefined) {
    uriEncode = false;
  }

  var macros = {};

  if (customMacros !== undefined) {
    macros = customMacros;
  }

  // Static macros
  macros['{player.id}'] = this.options_['data-player'];
  macros['{mediainfo.id}'] = this.mediainfo ? this.mediainfo.id : '';
  macros['{mediainfo.name}'] = this.mediainfo ? this.mediainfo.name : '';
  macros['{mediainfo.duration}'] = this.mediainfo ? this.mediainfo.duration : '';
  macros['{player.duration}'] = this.duration();
  macros['{timestamp}'] = new Date().getTime();
  macros['{document.referrer}'] = document_1.referrer;
  macros['{window.location.href}'] = window_1.location.href;
  macros['{random}'] = Math.floor(Math.random() * 1000000000000);

  ['description', 'tags', 'reference_id', 'ad_keys'].forEach(function (prop) {
    if (_this.mediainfo && _this.mediainfo[prop]) {
      macros['{mediainfo.' + prop + '}'] = _this.mediainfo[prop];
    } else if (defaults$$1['{mediainfo.' + prop + '}']) {
      macros['{mediainfo.' + prop + '}'] = defaults$$1['{mediainfo.' + prop + '}'];
    } else {
      macros['{mediainfo.' + prop + '}'] = '';
    }
  });

  // Custom fields in mediainfo
  customFields(this.mediainfo, macros, 'custom_fields');
  customFields(this.mediainfo, macros, 'customFields');

  // Go through all the replacement macros and apply them to the string.
  // This will replace all occurrences of the replacement macros.
  for (var i in macros) {
    string = string.split(i).join(uriEncodeIfNeeded(macros[i], uriEncode));
  }

  // Page variables
  string = string.replace(/{pageVariable\.([^}]+)}/g, function (match, name) {
    var value = void 0;
    var context = window_1;
    var names = name.split('.');

    // Iterate down multiple levels of selector without using eval
    // This makes things like pageVariable.foo.bar work
    for (var _i = 0; _i < names.length; _i++) {
      if (_i === names.length - 1) {
        value = context[names[_i]];
      } else {
        context = context[names[_i]];
      }
    }

    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

    // Only allow certain types of values. Anything else is probably a mistake.
    if (value === null) {
      return 'null';
    } else if (value === undefined) {
      if (defaults$$1['{pageVariable.' + name + '}']) {
        return defaults$$1['{pageVariable.' + name + '}'];
      }
      videojs$1.log.warn('Page variable "' + name + '" not found');
      return '';
    } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
      videojs$1.log.warn('Page variable "' + name + '" is not a supported type');
      return '';
    }

    return uriEncodeIfNeeded(String(value), uriEncode);
  });

  // Replace defaults
  for (var defaultVal in defaults$$1) {
    string = string.replace(defaultVal, defaults$$1[defaultVal]);
  }

  return string;
}

/*
* This feature allows metadata text tracks to be manipulated once available
* @see processMetadataTracks.
* It also allows ad implementations to leverage ad cues coming through
* text tracks, @see processAdTrack
**/

var cueTextTracks = {};

/*
* This feature allows metadata text tracks to be manipulated once they are available,
* usually after the 'loadstart' event is observed on the player
* @param player A reference to a player
* @param processMetadataTrack A callback that performs some operations on a
* metadata text track
**/
cueTextTracks.processMetadataTracks = function (player, processMetadataTrack) {
  var tracks = player.textTracks();
  var setModeAndProcess = function setModeAndProcess(track) {
    if (track.kind === 'metadata') {
      player.ads.cueTextTracks.setMetadataTrackMode(track);
      processMetadataTrack(player, track);
    }
  };

  // Text tracks are available
  for (var i = 0; i < tracks.length; i++) {
    setModeAndProcess(tracks[i]);
  }

  // Wait until text tracks are added
  tracks.addEventListener('addtrack', function (event) {
    setModeAndProcess(event.track);
  });
};

/*
* Sets the track mode to one of 'disabled', 'hidden' or 'showing'
* @see https://github.com/videojs/video.js/blob/master/docs/guides/text-tracks.md
* Default behavior is to do nothing, @override if this is not desired
* @param track The text track to set the mode on
*/
cueTextTracks.setMetadataTrackMode = function (track) {
  return;
};

/*
* Determines whether cue is an ad cue and returns the cue data.
* @param player A reference to the player
* @param cue The full cue object
* Returns the given cue by default @override if futher processing is required
* @return {Object} a useable ad cue or null if not supported
**/
cueTextTracks.getSupportedAdCue = function (player, cue) {
  return cue;
};

/*
* Defines whether a cue is supported or not, potentially
* based on the player settings
* @param player A reference to the player
* @param cue The cue to be checked
* Default behavior is to return true, @override if this is not desired
* @return {Boolean}
*/
cueTextTracks.isSupportedAdCue = function (player, cue) {
  return true;
};

/*
* Gets the id associated with a cue.
* @param cue The cue to extract an ID from
* @returns The first occurance of 'id' in the object,
* @override if this is not the desired cue id
**/
cueTextTracks.getCueId = function (player, cue) {
  return cue.id;
};

/*
* Checks whether a cue has already been used
* @param cueId The Id associated with a cue
**/
var cueAlreadySeen = function cueAlreadySeen(player, cueId) {
  return cueId !== undefined && player.ads.includedCues[cueId];
};

/*
* Indicates that a cue has been used
* @param cueId The Id associated with a cue
**/
var setCueAlreadySeen = function setCueAlreadySeen(player, cueId) {
  if (cueId !== undefined && cueId !== '') {
    player.ads.includedCues[cueId] = true;
  }
};

/*
* This feature allows ad metadata tracks to be manipulated in ad implementations
* @param player A reference to the player
* @param cues The set of cues to work with
* @param processCue A method that uses a cue to make some
* ad request in the ad implementation
* @param [cancelAdsHandler] A method that dynamically cancels ads in the ad implementation
**/
cueTextTracks.processAdTrack = function (player, cues, processCue, cancelAdsHandler) {
  player.ads.includedCues = {};

  // loop over set of cues
  for (var i = 0; i < cues.length; i++) {
    var cue = cues[i];
    var cueData = this.getSupportedAdCue(player, cue);

    // Exit if this is not a supported cue
    if (!this.isSupportedAdCue(player, cue)) {
      videojs$1.log.warn('Skipping as this is not a supported ad cue.', cue);
      return;
    }

    // Continue processing supported cue
    var cueId = this.getCueId(player, cue);
    var startTime = cue.startTime;

    // Skip ad if cue was already used
    if (cueAlreadySeen(player, cueId)) {
      videojs$1.log('Skipping ad already seen with ID ' + cueId);
      return;
    }

    // Optional dynamic ad cancellation
    if (cancelAdsHandler) {
      cancelAdsHandler(player, cueData, cueId, startTime);
    }

    // Process cue as an ad cue
    processCue(player, cueData, cueId, startTime);

    // Indicate that this cue has been used
    setCueAlreadySeen(player, cueId);
  }
};

var playMiddleware = obj$1.playMiddleware;
var isMiddlewareMediatorSupported$1 = obj$1.isMiddlewareMediatorSupported;

/**
 * Whether or not this copy of Video.js has the ads plugin.
 *
 * @return {boolean}
 *         If `true`, has the plugin. `false` otherwise.
 */

var hasAdsPlugin = function hasAdsPlugin() {

  // Video.js 6 and 7 have a getPlugin method.
  if (videojs$1.getPlugin) {
    return Boolean(videojs$1.getPlugin('ads'));
  }

  // Video.js 5 does not have a getPlugin method, so check the player prototype.
  var Player = videojs$1.getComponent('Player');

  return Boolean(Player && Player.prototype.ads);
};

/**
 * Register contrib-ads with Video.js, but provide protection for duplicate
 * copies of the plugin. This could happen if, for example, a stitched ads
 * plugin and a client-side ads plugin are included simultaneously with their
 * own copies of contrib-ads.
 *
 * If contrib-ads detects a pre-existing duplicate, it will not register
 * itself.
 *
 * Ad plugins using contrib-ads and anticipating that this could come into
 * effect should verify that the contrib-ads they are using is of a compatible
 * version.
 *
 * @param  {Function} contribAdsPlugin
 *         The plugin function.
 *
 * @return {boolean}
 *         When `true`, the plugin was registered. When `false`, the plugin
 *         was not registered.
 */
function register(contribAdsPlugin) {

  // If the ads plugin already exists, do not overwrite it.
  if (hasAdsPlugin(videojs$1)) {
    return false;
  }

  // Cross-compatibility with Video.js 6/7 and 5.
  var registerPlugin = videojs$1.registerPlugin || videojs$1.plugin;

  // Register this plugin with Video.js.
  registerPlugin('ads', contribAdsPlugin);

  // Register the play middleware with Video.js on script execution,
  // to avoid a new playMiddleware factory being added for each player.
  // The `usingContribAdsMiddleware_` flag is used to ensure that we only ever
  // register the middleware once - despite the ability to de-register and
  // re-register the plugin itself.
  if (isMiddlewareMediatorSupported$1() && !videojs$1.usingContribAdsMiddleware_) {
    // Register the play middleware
    videojs$1.use('*', playMiddleware);
    videojs$1.usingContribAdsMiddleware_ = true;
    videojs$1.log('Play middleware has been registered with videojs');
  }

  return true;
}

/*
This main plugin file is responsible for the public API and enabling the features
that live in in separate files.
*/

var isMiddlewareMediatorSupported = obj$1.isMiddlewareMediatorSupported;

var VIDEO_EVENTS = videojs$1.getTech('Html5').Events;

// Default settings
var defaults$1 = {
  // Maximum amount of time in ms to wait to receive `adsready` from the ad
  // implementation after play has been requested. Ad implementations are
  // expected to load any dynamic libraries and make any requests to determine
  // ad policies for a video during this time.
  timeout: 5000,

  // Maximum amount of time in ms to wait for the ad implementation to start
  // linear ad mode after `readyforpreroll` has fired. This is in addition to
  // the standard timeout.
  prerollTimeout: undefined,

  // Maximum amount of time in ms to wait for the ad implementation to start
  // linear ad mode after `readyforpostroll` has fired.
  postrollTimeout: undefined,

  // When truthy, instructs the plugin to output additional information about
  // plugin state to the video.js log. On most devices, the video.js log is
  // the same as the developer console.
  debug: false,

  // Set this to true when using ads that are part of the content video
  stitchedAds: false,

  // Force content to be treated as live or not live
  // if not defined, the code will try to infer if content is live,
  // which can have limitations.
  contentIsLive: undefined,

  // If set to true, content will play muted behind ads on supported platforms. This is
  // to support ads on video metadata cuepoints during a live stream. It also results in
  // more precise resumes after ads during a live stream.
  liveCuePoints: true
};

var contribAdsPlugin = function contribAdsPlugin(options) {

  var player = this; // eslint-disable-line consistent-this

  var settings = videojs$1.mergeOptions(defaults$1, options);

  // Prefix all video element events during ad playback
  // if the video element emits ad-related events directly,
  // plugins that aren't ad-aware will break. prefixing allows
  // plugins that wish to handle ad events to do so while
  // avoiding the complexity for common usage
  var videoEvents = VIDEO_EVENTS.concat(['firstplay', 'loadedalldata', 'playing']);

  // Set up redispatching of player events
  player.on(videoEvents, redispatch);

  // Set up features to block content playback while waiting for ads.
  // Play middleware is only supported on later versions of video.js
  // and on desktop currently(as the user-gesture requirement on mobile
  // will disallow calling play once play blocking is lifted)
  // The middleware must also be registered outside of the plugin,
  // to avoid a middleware factory being created for each player
  if (!isMiddlewareMediatorSupported()) {
    initCancelContentPlay(player, settings.debug);
  }

  // If we haven't seen a loadstart after 5 seconds, the plugin was not initialized
  // correctly.
  player.setTimeout(function () {
    if (!player.ads._hasThereBeenALoadStartDuringPlayerLife && player.src() !== '') {
      videojs$1.log.error('videojs-contrib-ads has not seen a loadstart event 5 seconds ' + 'after being initialized, but a source is present. This indicates that ' + 'videojs-contrib-ads was initialized too late. It must be initialized ' + 'immediately after video.js in the same tick. As a result, some ads will not ' + 'play and some media events will be incorrect. For more information, see ' + 'http://videojs.github.io/videojs-contrib-ads/integrator/getting-started.html');
    }
  }, 5000);

  // "vjs-has-started" should be present at the end of a video. This makes sure it's
  // always there.
  player.on('ended', function () {
    if (!player.hasClass('vjs-has-started')) {
      player.addClass('vjs-has-started');
    }
  });

  // video.js removes the vjs-waiting class on timeupdate. We want
  // to make sure this still happens during content restoration.
  player.on('contenttimeupdate', function () {
    player.removeClass('vjs-waiting');
  });

  // We now auto-play when an ad gets loaded if we're playing ads in the same video
  // element as the content.
  // The problem is that in IE11, we cannot play in addurationchange but in iOS8, we
  // cannot play from adcanplay.
  // This will prevent ad plugins from needing to do this themselves.
  player.on(['addurationchange', 'adcanplay'], function () {
    if (player.ads.snapshot && player.currentSrc() === player.ads.snapshot.currentSrc) {
      return;
    }

    // If an ad isn't playing, don't try to play an ad. This could result from prefixed
    // events when the player is blocked by a preroll check, but there is no preroll.
    if (!player.ads.inAdBreak()) {
      return;
    }

    var playPromise = player.play();

    if (playPromise && playPromise['catch']) {
      playPromise['catch'](function (error) {
        videojs$1.log.warn('Play promise rejected when playing ad', error);
      });
    }
  });

  player.on('nopreroll', function () {
    player.ads.debug('Received nopreroll event');
    player.ads.nopreroll_ = true;
  });

  player.on('nopostroll', function () {
    player.ads.debug('Received nopostroll event');
    player.ads.nopostroll_ = true;
  });

  // Restart the cancelContentPlay process.
  player.on('playing', function () {
    player.ads._cancelledPlay = false;
    player.ads._pausedOnContentupdate = false;
  });

  // Keep track of whether a play event has happened
  player.on('play', function () {
    player.ads._playRequested = true;
  });

  player.one('loadstart', function () {
    player.ads._hasThereBeenALoadStartDuringPlayerLife = true;
  });

  player.on('loadeddata', function () {
    player.ads._hasThereBeenALoadedData = true;
  });

  player.on('loadedmetadata', function () {
    player.ads._hasThereBeenALoadedMetaData = true;
  });

  // Replace the plugin constructor with the ad namespace
  player.ads = getAds(player);

  player.ads.settings = settings;

  // Set the stitched ads state. This needs to happen before the `_state` is
  // initialized below - BeforePreroll needs to know whether contrib-ads is
  // playing stitched ads or not.
  // The setter is deprecated, so this does not use it.
  // But first, cast to boolean.
  settings.stitchedAds = !!settings.stitchedAds;

  if (settings.stitchedAds) {
    player.ads._state = new StitchedContentPlayback(player);
  } else {
    player.ads._state = new BeforePreroll(player);
  }

  player.ads._state.init(player);

  player.ads.cueTextTracks = cueTextTracks;
  player.ads.adMacroReplacement = adMacroReplacement.bind(player);

  // Start sending contentupdate and contentchanged events for this player
  initializeContentupdate(player);

  // Global contentchanged handler for resetting plugin state
  player.on('contentchanged', player.ads.reset);

  // A utility method for textTrackChangeHandler to define the conditions
  // when text tracks should be disabled.
  // Currently this includes:
  //  - on iOS with native text tracks, during an ad playing
  var shouldDisableTracks = function shouldDisableTracks() {
    // If the platform matches iOS with native text tracks
    // and this occurs during ad playback, we should disable tracks again.
    // If shouldPlayContentBehindAd, no special handling is needed.
    return !player.ads.shouldPlayContentBehindAd(player) && player.ads.inAdBreak() && player.tech_.featuresNativeTextTracks && videojs$1.browser.IS_IOS &&
    // older versions of video.js did not use an emulated textTrackList
    !Array.isArray(player.textTracks());
  };

  /*
   * iOS Safari will change caption mode to 'showing' if a user previously
   * turned captions on manually for that video source, so this TextTrackList
   * 'change' event handler will re-disable them in case that occurs during ad playback
   */
  var textTrackChangeHandler = function textTrackChangeHandler() {
    var textTrackList = player.textTracks();

    if (shouldDisableTracks()) {
      // We must double check all tracks
      for (var i = 0; i < textTrackList.length; i++) {
        var track = textTrackList[i];

        if (track.mode === 'showing') {
          track.mode = 'disabled';
        }
      }
    }
  };

  // Add the listener to the text track list
  player.ready(function () {
    player.textTracks().addEventListener('change', textTrackChangeHandler);
  });

  // Event handling for the current state.
  player.on(['play', 'playing', 'ended', 'adsready', 'adscanceled', 'adskip', 'adserror', 'adtimeout', 'adended', 'ads-ad-started', 'contentchanged', 'dispose', 'contentresumed', 'readyforpostroll', 'nopreroll', 'nopostroll'], function (e) {
    player.ads._state.handleEvent(e.type);
  });

  // Clear timeouts and handlers when player is disposed
  player.on('dispose', function () {
    player.ads.reset();
    player.textTracks().removeEventListener('change', textTrackChangeHandler);
  });
};

// Expose the contrib-ads version before it is initialized. Will be replaced
// after initialization in ads.js
contribAdsPlugin.VERSION = version;

// Attempt to register the plugin, if we can.
register(contribAdsPlugin);

// Cross-compatible plugin de-registration.
var deregister = function deregister() {

  // Video.js 7.2+
  if (videojs$1.deregisterPlugin) {
    return videojs$1.deregisterPlugin('ads');
  }

  // Video.js 6.0 thru 7.1
  if (videojs$1.getPlugin) {
    var Plugin = videojs$1.getPlugin('plugin');

    if (Plugin && Plugin.deregisterPlugin) {
      return Plugin.deregisterPlugin('ads');
    }
  }

  // Video.js 5
  var Player = videojs$1.getComponent('Player');

  if (Player && Player.prototype.ads) {
    delete Player.prototype.ads;
  }
};

QUnit.module('Register');

QUnit.test('registration fails if plugin exists, succeeds otherwise', function (assert) {

  // The plugin is already registered here.
  assert.notOk(register(contribAdsPlugin), 'plugin was already registered');
  assert.ok(hasAdsPlugin(), 'plugin exists');

  // De-register the plugin and verify that it no longer exists.
  deregister();
  assert.notOk(hasAdsPlugin(), 'plugin does not exist');

  // Re-register the plugin and verify that it exists.
  assert.ok(register(contribAdsPlugin), 'plugin was registered');
  assert.ok(hasAdsPlugin(), 'plugin exists');
});

}(videojs));
